diff --git a/pulse2/configure.ac b/pulse2/configure.ac
index 5db21b9..575a7f6 100644
--- a/pulse2/configure.ac
+++ b/pulse2/configure.ac
@@ -166,7 +166,6 @@ AC_CONFIG_FILES([services/contrib/msc/quick_actions/Makefile])
 AC_CONFIG_FILES([services/contrib/inventory/Makefile])
 AC_CONFIG_FILES([services/contrib/inventory/sql/Makefile])
 AC_CONFIG_FILES([services/contrib/imaging-server/Makefile])
-AC_CONFIG_FILES([services/contrib/imaging-server/hooks/Makefile])
 AC_CONFIG_FILES([services/contrib/dyngroup/Makefile])
 AC_CONFIG_FILES([services/contrib/dyngroup/sql/Makefile])
 AC_CONFIG_FILES([services/contrib/backuppc/Makefile])
@@ -182,7 +181,6 @@ AC_CONFIG_FILES([services/conf/Makefile])
 AC_CONFIG_FILES([services/conf/plugins/Makefile])
 AC_CONFIG_FILES([services/conf/pulse2/Makefile])
 AC_CONFIG_FILES([services/init.d/Makefile])
-AC_CONFIG_FILES([services/src/Makefile])
 AC_CONFIG_FILES([services/3rd_party/Makefile])
 AC_CONFIG_FILES([services/clients/Makefile])
 AC_CONFIG_FILES([services/clients/win32/Makefile])
diff --git a/pulse2/services/Makefile.am b/pulse2/services/Makefile.am
index 91d4433..41817b2 100644
--- a/pulse2/services/Makefile.am
+++ b/pulse2/services/Makefile.am
@@ -20,4 +20,4 @@
 # Author(s):
 #   Jean Parpaillon <jparpaillon@mandriva.com>
 #
-SUBDIRS = init.d src 3rd_party bin contrib mmc pulse2 conf clients
+SUBDIRS = init.d 3rd_party bin contrib mmc pulse2 conf clients
diff --git a/pulse2/services/contrib/imaging-server/Makefile.am b/pulse2/services/contrib/imaging-server/Makefile.am
index 7bc6a9b..1a642f5 100644
--- a/pulse2/services/contrib/imaging-server/Makefile.am
+++ b/pulse2/services/contrib/imaging-server/Makefile.am
@@ -20,8 +20,6 @@
 # Author(s):
 #   Jean Parpaillon <jparpaillon@mandriva.com>
 #
-SUBDIRS = hooks
-
 MAINTAINERCLEANFILES = pci.ids README.pci.ids
 
 EXTRA_DIST = dhcpd.conf pci.ids README.exports README.pci.ids README.tftp-server \
diff --git a/pulse2/services/contrib/imaging-server/hooks/Makefile.am b/pulse2/services/contrib/imaging-server/hooks/Makefile.am
deleted file mode 100644
index 7a23bc4..0000000
--- a/pulse2/services/contrib/imaging-server/hooks/Makefile.am
+++ /dev/null
@@ -1,28 +0,0 @@
-# (c) 2011 Mandriva, http://www.mandriva.com
-#
-# $Id$
-#
-# This file is part of Mandriva Pulse2 project.
-#
-# This software is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This software is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this software.  If not, see <http://www.gnu.org/licenses/>.
-#
-# Author(s):
-#   Jean Parpaillon <jparpaillon@mandriva.com>
-#
-hooksdir = $(pkglibdir)/imaging-server/hooks
-dist_hooks_SCRIPTS = boot_client change_default create_client end_image \
-	get_hostname get_uuid log_action mtftp_sync \
-	process_inventory start_image client_auth
-
-EXTRA_DIST = generic_hook.py
diff --git a/pulse2/services/contrib/imaging-server/hooks/boot_client b/pulse2/services/contrib/imaging-server/hooks/boot_client
deleted file mode 100755
index 33a2cf5..0000000
--- a/pulse2/services/contrib/imaging-server/hooks/boot_client
+++ /dev/null
@@ -1,178 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8; -*-
-#
-# (c) 2010 Mandriva, http://www.mandriva.com
-#
-# $Id$
-#
-# This file is part of Pulse 2, http://pulse2.mandriva.org
-#
-# Pulse 2 is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# Pulse 2 is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Pulse 2. If not, see <http://www.gnu.org/licenses/>.
-#
-
-"""
-    This is a generic hook skeleton to be used with pulse 2 imaging server
-"""
-import sys
-import twisted.internet.reactor
-import logging
-import logging.config
-from mmc.site import mmcconfdir
-import pulse2.apis.clients.imaging
-import pulse2.imaging_server.config
-
-CONFIG_FILE = mmcconfdir + '/pulse2/imaging-server/imaging-server.ini' #: config file location
-
-# default error code
-ERROR_OK = 0        #: no error
-ERROR_SERVER = 1    #: error server-side
-ERROR_CLIENT = 2    #: error client-side (here)
-ERROR_UNKNOWN = 3   #: unknow (and default) error
-exitcode = ERROR_UNKNOWN #: global error code, used when exiting
-
-########################################################################
-#         NOTHING SHOULD BE ALTERED ABOVE THIS LINE                    #
-########################################################################
-
-
-def myCall():
-    """
-        Design your own call here
-
-        a deferred should be passed to callFunction()
-    """
-    global exitcode
-
-    mac = '' # client MAC address
-
-    if len(sys.argv) != 2: # not enough (or too much) args
-        logging.getLogger().error('HOOK %s : I was not called with the right number of arguments (one expected, got %d)' % (sys.argv[0], len(sys.argv) - 1))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    mac = sys.argv[1]
-
-    if not pulse2.utils.isMACAddress(mac):
-        logging.getLogger().error('HOOK %s : First arg (%s) do not seems to be a MAC address' % (sys.argv[0], mac))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    try:
-        callFunction(imagingAPI.computerMenuUpdate(mac))
-    except AttributeError, e:
-        logging.getLogger().error('HOOK %s : %s' % (sys.argv[0], e))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-
-def myTreatment(result):
-    """
-        Design your own treatment here
-
-        don't forget to set exitcode and finally call endBack()
-    """
-    global exitcode
-    if result and result != None:
-        exitcode= ERROR_OK
-        logging.getLogger().info('HOOK %s : SUCCESS !' % sys.argv[0])
-    else:
-        exitcode = ERROR_SERVER
-        logging.getLogger().error('HOOK %s : Error server side !' % sys.argv[0])
-
-    # nothing else to do
-    return endBack()
-
-########################################################################
-#         NOTHING SHOULD BE ALTERED BELOW THIS LINE                    #
-########################################################################
-
-
-def endBack(when = None):
-    """
-        take the reactor down
-    """
-    if when == "timeout" :
-        logging.getLogger().error('HOOK %s : Killed by a timeout' % sys.argv[0])
-    twisted.internet.reactor.callLater(0, twisted.internet.reactor.stop)
-
-
-def callBack(result):
-    """
-        XMLRPC result treatment
-
-        check if it was a success by analysing result
-        if it is a success, call myCall(result)
-        if not, exitcode is set to ERROR_SERVER then call endBack()
-    """
-
-    global exitcode
-    # if result is a list and the first arg a string and its value,
-    # 'PULSE2_ERR', then something went wrong
-    if type(result) == list and len(result) > 0 and type(result[0]) == str and result[0] == 'PULSE2_ERR':
-        logging.getLogger().error("HOOK %s : Error code = %d (see previous line)" % (sys.argv[0], result[1]))
-        exitcode = ERROR_SERVER
-        return endBack()
-    else:
-        logging.getLogger().debug("%s : No error" % (sys.argv[0]))
-        exitcode = ERROR_CLIENT
-        myTreatment(result)
-
-
-def errorBack(reason):
-    """
-        XMLRPC error treatment
-
-        just set exitcode to ERROR_CLIENT then call endBack()
-    """
-    global exitcode
-    exitcode = ERROR_CLIENT
-    return endBack()
-
-
-def callFunction(deffered):
-    """
-        XMLRPC request handling
-
-        attach callBack() and errorBack() to the deferred
-    """
-    deffered.addCallbacks( # deferred handling
-        callBack,
-        errorBack)
-
-# Parse the command line
-config = pulse2.imaging_server.config.ImagingConfig() #: ConfigParser object
-config.setup(CONFIG_FILE)
-logging.config.fileConfig(CONFIG_FILE)
-
-# Instanciate the API
-imagingAPI = pulse2.apis.clients.imaging.ImagingApi({
-    "server" : config.pserver_host,
-    "port" : config.pserver_port,
-    "mountpoint" : config.pserver_mount_point,
-    "enablessl" : config.pserver_enablessl,
-    "username" : config.pserver_username,
-    "password" : config.pserver_password,
-    "verifypeer" : config.pserver_verifypeer,
-    "localcert" : config.pserver_localcert,
-    "cacert" : config.pserver_cacert,
-}) #: Object which will be used to speak with our pserver
-
-# anti-blocking stuff
-# I have 30 seconds to get my result or be killed
-twisted.internet.reactor.callLater(10, endBack, "timeout")
-
-# fire the reactor
-twisted.internet.reactor.callWhenRunning(myCall)
-twisted.internet.reactor.run()
-sys.exit(exitcode)
diff --git a/pulse2/services/contrib/imaging-server/hooks/change_default b/pulse2/services/contrib/imaging-server/hooks/change_default
deleted file mode 100755
index c658de4..0000000
--- a/pulse2/services/contrib/imaging-server/hooks/change_default
+++ /dev/null
@@ -1,188 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8; -*-
-#
-# (c) 2010 Mandriva, http://www.mandriva.com
-#
-# $Id$
-#
-# This file is part of Pulse 2, http://pulse2.mandriva.org
-#
-# Pulse 2 is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# Pulse 2 is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Pulse 2. If not, see <http://www.gnu.org/licenses/>.
-#
-
-"""
-    This is a generic hook skeleton to be used with pulse 2 imaging server
-"""
-import sys
-import twisted.internet.reactor
-import logging
-import logging.config
-from mmc.site import mmcconfdir
-import pulse2.apis.clients.imaging
-import pulse2.imaging_server.config
-
-CONFIG_FILE = mmcconfdir + '/pulse2/imaging-server/imaging-server.ini' #: config file location
-
-# default error code
-ERROR_OK = 0        #: no error
-ERROR_SERVER = 1    #: error server-side
-ERROR_CLIENT = 2    #: error client-side (here)
-ERROR_UNKNOWN = 3   #: unknow (and default) error
-exitcode = ERROR_UNKNOWN #: global error code, used when exiting
-
-########################################################################
-#         NOTHING SHOULD BE ALTERED ABOVE THIS LINE                    #
-########################################################################
-
-
-def myCall():
-    """
-        Design your own call here
-
-        a deferred should be passed to callFunction()
-    """
-    global exitcode
-
-    mac = '' # client MAC address
-    requested_menu = 0 # requeste menu
-
-    if len(sys.argv) != 3: # not enough (or too much) args
-        logging.getLogger().error('HOOK %s : I was not called with the right number of arguments (two expected, got %d)' % (sys.argv[0], len(sys.argv) - 1))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    mac = sys.argv[1]
-
-    if not pulse2.utils.isMACAddress(mac):
-        logging.getLogger().error('HOOK %s : First arg (%s) do not seems to be a MAC address' % (sys.argv[0], mac))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    requested_menu = sys.argv[2]
-  
-    try:
-        int(requested_menu)
-    except ValueError:
-        logging.getLogger().error('HOOK %s : Second argument is not a number (%s), giving up' % (sys.argv[0], sys.argv[2]))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    try:
-        callFunction(imagingAPI.computerChangeDefaultMenuItem(mac, requested_menu))
-    except AttributeError, e:
-        logging.getLogger().error('HOOK %s : %s' % (sys.argv[0], e))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-
-def myTreatment(result):
-    """
-        Design your own treatment here
-
-        don't forget to set exitcode and finally call endBack()
-    """
-    global exitcode
-    if result and result != None:
-        exitcode= ERROR_OK
-        logging.getLogger().info('HOOK %s : SUCCESS !' % sys.argv[0])
-    else:
-        exitcode = ERROR_SERVER
-        logging.getLogger().error('HOOK %s : Error server side !' % sys.argv[0])
-
-    # nothing else to do
-    return endBack()
-
-########################################################################
-#         NOTHING SHOULD BE ALTERED BELOW THIS LINE                    #
-########################################################################
-
-
-def endBack(when = None):
-    """
-        take the reactor down
-    """
-    if when == "timeout" :
-        logging.getLogger().error('HOOK %s : Killed by a timeout' % sys.argv[0])
-    twisted.internet.reactor.callLater(0, twisted.internet.reactor.stop)
-
-
-def callBack(result):
-    """
-        XMLRPC result treatment
-
-        check if it was a success by analysing result
-        if it is a success, call myCall(result)
-        if not, exitcode is set to ERROR_SERVER then call endBack()
-    """
-
-    global exitcode
-    # if result is a list and the first arg a string and its value,
-    # 'PULSE2_ERR', then something went wrong
-    if type(result) == list and len(result) > 0 and type(result[0]) == str and result[0] == 'PULSE2_ERR':
-        logging.getLogger().error("HOOK %s : Error code = %d (see previous line)" % (sys.argv[0], result[1]))
-        exitcode = ERROR_SERVER
-        return endBack()
-    else:
-        logging.getLogger().debug("%s : No error" % (sys.argv[0]))
-        exitcode = ERROR_CLIENT
-        myTreatment(result)
-
-
-def errorBack(reason):
-    """
-        XMLRPC error treatment
-
-        just set exitcode to ERROR_CLIENT then call endBack()
-    """
-    global exitcode
-    exitcode = ERROR_CLIENT
-    return endBack()
-
-
-def callFunction(deffered):
-    """
-        XMLRPC request handling
-
-        attach callBack() and errorBack() to the deferred
-    """
-    deffered.addCallbacks( # deferred handling
-        callBack,
-        errorBack)
-
-# Parse the command line
-config = pulse2.imaging_server.config.ImagingConfig() #: ConfigParser object
-config.setup(CONFIG_FILE)
-logging.config.fileConfig(CONFIG_FILE)
-
-# Instanciate the API
-imagingAPI = pulse2.apis.clients.imaging.ImagingApi({
-    "server" : config.pserver_host,
-    "port" : config.pserver_port,
-    "mountpoint" : config.pserver_mount_point,
-    "enablessl" : config.pserver_enablessl,
-    "username" : config.pserver_username,
-    "password" : config.pserver_password,
-    "verifypeer" : config.pserver_verifypeer,
-    "localcert" : config.pserver_localcert,
-    "cacert" : config.pserver_cacert,
-}) #: Object which will be used to speak with our pserver
-
-# anti-blocking stuff
-# I have 30 seconds to get my result or be killed
-twisted.internet.reactor.callLater(10, endBack, "timeout")
-
-# fire the reactor
-twisted.internet.reactor.callWhenRunning(myCall)
-twisted.internet.reactor.run()
-sys.exit(exitcode)
diff --git a/pulse2/services/contrib/imaging-server/hooks/client_auth b/pulse2/services/contrib/imaging-server/hooks/client_auth
deleted file mode 100755
index 09d1e43..0000000
--- a/pulse2/services/contrib/imaging-server/hooks/client_auth
+++ /dev/null
@@ -1,45 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8; -*-
-#
-# (c) 2010 Mandriva, http://www.mandriva.com
-#
-# $Id$
-#
-# This file is part of Pulse 2, http://pulse2.mandriva.org
-#
-# Pulse 2 is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# Pulse 2 is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Pulse 2. If not, see <http://www.gnu.org/licenses/>.
-#
-
-"""
-    This hook is called when a client asks to be authentifier.    
-"""
-import sys
-import logging
-hook = sys.argv[0]
-mac = ""  # client MAC address
-pwd = "" # client ID
-
-if len(sys.argv) == 3:
-    logging.info('HOOK %s : verify password' % hook)
-else:
-    logging.warning('HOOK %s : arg ' % hook)
-    sys.exit(0)
-mac = sys.argv[2]
-pwd = sys.argv[1]
-#fonction de verification du password menu
-#fonction apres verification password
-# envoi ok si verification bonne
-sys.exit(0)
-#envoi ko si verification mauvaise
-#sys.exit(0)
diff --git a/pulse2/services/contrib/imaging-server/hooks/create_client b/pulse2/services/contrib/imaging-server/hooks/create_client
deleted file mode 100755
index cc8668b..0000000
--- a/pulse2/services/contrib/imaging-server/hooks/create_client
+++ /dev/null
@@ -1,351 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8; -*-
-#
-# (c) 2010 Mandriva, http://www.mandriva.com
-#
-# $Id$
-#
-# This file is part of Pulse 2, http://pulse2.mandriva.org
-#
-# Pulse 2 is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# Pulse 2 is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Pulse 2. If not, see <http://www.gnu.org/licenses/>.
-#
-
-"""
-    This hook is called when a client asks to be declared.
-
-    For the curious mind, if correspond to the following GRUB keywords:
-    - identify (name and password given by the user)
-    - identifyauto (server is left alone) : deprecated, LRS stuff
-"""
-import sys
-import twisted.internet.reactor
-from twisted.internet import task
-import logging
-import logging.config
-from mmc.site import mmcconfdir
-import pulse2.apis.clients.imaging
-import pulse2.utils
-import pulse2.imaging_server.config
-
-CONFIG_FILE = mmcconfdir + '/pulse2/imaging-server/imaging-server.ini' #: config file location
-
-# default error code
-ERROR_OK = 0        #: no error
-ERROR_SERVER = 1    #: error server-side
-ERROR_CLIENT = 2    #: error client-side (here)
-ERROR_UNKNOWN = 3   #: unknow (and default) error
-exitcode = ERROR_UNKNOWN #: global error code, used when exiting
-
-logger = logging.getLogger()
-
-########################################################################
-#         NOTHING SHOULD BE ALTERED ABOVE THIS LINE                    #
-########################################################################
-
-
-
-class RegisterByInventory :
-    """
-    Registering a new computer by sending the inventory. 
-    
-    Used on GLPI mode where the method computerRegister 
-    is not accessible (GLPI backend is read-only).
-    """
-    # When GLPI mode is a special case, all imports 
-    # are encapsulated in this class to avoid 
-    # the unusuals imports when we are using
-    # only Pulse on stand-allone mode.
-
-    def __init__(self, config):
-        """
-        @param config: imaging server config container
-        @type config: ImagingConfig
-        """
-        if config.invserver_enablessl :
-            protocol = "https"
-        else :
-            protocol = "http"
-
-        self._url = "%s://%s:%s/" % (protocol, config.invserver_host, config.invserver_port)
-
-
-    def send(self, hostname, mac, ip_addr):
-        """
-        Send the minimal inventory to URL of inventory server.
-
-        @param hostname: computer's hostname
-        @type hostname: str
-        @param mac: MAC address on standard format xx:xx:xx:xx:xx:xx
-        @type mac: str
-        @param ip_addr: IP address
-        @type ip_addr: str
-        """
-        from pulse2.imaging.bootinventory import BootInventory
-        from twisted.web.client import Agent
- 
-        boot_inv = BootInventory()
-        boot_inv.macaddr_info = mac
-        boot_inv.ipaddr_info = {'ip': ip_addr, 'port': 0}
-
-        self.inventory = boot_inv.dumpOCS(hostname, "root")
-
-        logging.getLogger().debug("Registering the computer '%s'by inventory" % hostname)
-
-        agent = Agent(twisted.internet.reactor)
-
-        # POST the inventory to the inventory server
-        defer = agent.request('POST', self._url, self._headers, self._content)
-        defer.addCallbacks(self._callBack, self._errorBack)
-
-        return defer
-
-    @property
-    def _headers(self):
-        """
-        @return: headers for POST method
-        @rtype: str
-        """
-        from twisted.web.http_headers import Headers
-        return Headers({'Content-Type': ['application/x-www-form-urlencoded'],
-                        'Content-Length': [str(len(self.inventory))],
-                        'User-Agent': ['Pulse2 Imaging server inventory register']
-                        })
- 
-    @property
-    def _content(self):
-        """
-        @return: content to post
-        @rtype: str
-        """
-        from zope.interface import implements
-        from twisted.web.iweb import IBodyProducer
-        from twisted.internet.defer import succeed
-
-        class StringProducer(object):
-            implements(IBodyProducer)
-
-            def __init__(self, string):
-                self.body = string
-                self.length = len(self.body)
-
-            def startProducing(self, consumer):
-                consumer.write(self.body)
-                return succeed(None)
-
-        return StringProducer(self.inventory)
-
-
-    def _errorBack (self, reason):
-
-        logging.getLogger().debug('Error while sending the register inventory : %s' % str(reason))
-        return endBack()
-
-    def _callBack(self, result):
-
-        global exitcode
-
-        if result.code != 200:
-            logging.getLogger().error("HOOK %s : Error sending the inventory to the inventory server" % sys.argv[0])
-            logging.getLogger().error(result.phrase)
-            exitcode = ERROR_SERVER
-        else:
-            logging.getLogger().debug("%s : Inventory sent to the inventory server" % sys.argv[0])
-
-            if result and result != None:
-                exitcode = ERROR_OK
-                logging.getLogger().info('HOOK %s : SUCCESS (inventory OK)' % sys.argv[0])
-            else:
-                exitcode = ERROR_SERVER
-                logging.getLogger().error('HOOK %s : Error (inventory NOK)' % sys.argv[0])
-
-
-def myCall():
-    """
-        Design your own call here
-
-        a deferred should be passed to callFunction()
-    """
-    global exitcode
-
-    hook = sys.argv[0]
-    mac = '' # client MAC address
-    name = '' # client ID
-    ip_addr = '' # client IP address
-    key = '' # registering password (not used)
-    if len(sys.argv) == 2: # "mac" version
-        mac = sys.argv[1]
-        logger.warning('HOOK %s : I was not given an name, proceeding anyway' % hook)
-    elif len(sys.argv) == 3: # "mac + name" version
-        mac = sys.argv[1]
-        name = sys.argv[2]
-    elif len(sys.argv) == 4: # "mac + name + ip_address" version
-        mac = sys.argv[1]
-        name = sys.argv[2]
-        ip_addr = sys.argv[3]
-    elif len(sys.argv) == 5: # "mac + name + ip_address + pass" version
-        mac = sys.argv[1]
-        name = sys.argv[2]
-        ip_addr = sys.argv[3]
-        key = sys.argv[4]
-        logger.warning('HOOK %s : I was given a password, but I don\'t now what to do woth it, so I dropped it' % hook)
-    else:
-        logger.error('HOOK %s : I was not called with the right number of arguments (one to three expected, got %d)' % (hook, len(sys.argv) - 1))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    if not pulse2.utils.isMACAddress(mac):
-        logger.error('HOOK %s : First arg (%s) do not seems to be a MAC address' % (hook, mac))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    if not len(name):
-        logger.error('HOOK %s : No name given' % hook)
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    logger.debug('HOOK %s : Going to register computer %s (%s)' % (hook, name, mac))
-
-    try:
-        if config.invserver_glpi_mode :
-            invfwd = RegisterByInventory(config)
-            defer_inv = task.deferLater(twisted.internet.reactor, 0, invfwd.send, name, mac, ip_addr)
-            defer_inv.addErrback(errorBack)
-
-            defer_reg = task.deferLater(twisted.internet.reactor, 
-                                        2, 
-                                        imagingAPI.computerRegister, 
-                                        name, 
-                                        mac, 
-                                        False, # imagingData
-                                        True   # waitToBeInventoried
-                                        )
-            defer_reg.addCallback(callBack)
-            defer_reg.addErrback(errorBack)
-        else :
-            callFunction(
-                imagingAPI.computerRegister(
-                    name,
-                    mac,
-                    False, # imagingData = False, since we are not the mmc agent !
-                    False  # waitToBeInventoried 
-                )
-            )
-            
-    except AttributeError, e:
-        logger.error('HOOK %s : %s' % (hook, e))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-
-def myTreatment(result):
-    """
-        Design your own treatment here
-
-        don't forget to set exitcode and finally call endBack()
-    """
-    global exitcode
-    hook = sys.argv[0]
-
-    if result and result != None:
-        exitcode= ERROR_OK
-        logger.info('HOOK %s : SUCCESS !' % hook)
-    else:
-        exitcode = ERROR_SERVER
-        logger.error('HOOK %s : Error server side !' % hook)
-
-    # nothing else to do
-    return endBack()
-
-########################################################################
-#         NOTHING SHOULD BE ALTERED BELOW THIS LINE                    #
-########################################################################
-
-
-def endBack(when = None):
-    """
-        take the reactor down
-    """
-    if when == "timeout" :
-        logger.error('HOOK %s : Killed by a timeout' % sys.argv[0])
-    twisted.internet.reactor.callLater(0, twisted.internet.reactor.stop)
-
-
-def callBack(result):
-    """
-        XMLRPC result treatment
-
-        check if it was a success by analysing result
-        if it is a success, call myCall(result)
-        if not, exitcode is set to ERROR_SERVER then call endBack()
-    """
-    global exitcode
-    # if result is a list and the first arg a string and its value,
-    # 'PULSE2_ERR', then something went wrong
-    if type(result) == list and len(result) > 0 and type(result[0]) == str and result[0] == 'PULSE2_ERR':
-        logger.error("HOOK %s : Error code = %d (see previous line)" % (sys.argv[0], result[1]))
-        exitcode = ERROR_SERVER
-        return endBack()
-    else:
-        logger.debug("%s : No error" % (sys.argv[0]))
-        exitcode = ERROR_CLIENT
-        myTreatment(result)
-
-
-def errorBack(reason):
-    """
-        XMLRPC error treatment
-
-        just set exitcode to ERROR_CLIENT then call endBack()
-    """
-    global exitcode
-    exitcode = ERROR_CLIENT
-    return endBack()
-
-
-def callFunction(deffered):
-    """
-        XMLRPC request handling
-
-        attach callBack() and errorBack() to the deferred
-    """
-    deffered.addCallbacks( # deferred handling
-        callBack,
-        errorBack)
-
-# Parse the command line
-config = pulse2.imaging_server.config.ImagingConfig() #: ConfigParser object
-config.setup(CONFIG_FILE)
-logging.config.fileConfig(CONFIG_FILE)
-
-# Instanciate the API
-imagingAPI = pulse2.apis.clients.imaging.ImagingApi({
-    "server" : config.pserver_host,
-    "port" : config.pserver_port,
-    "mountpoint" : config.pserver_mount_point,
-    "enablessl" : config.pserver_enablessl,
-    "username" : config.pserver_username,
-    "password" : config.pserver_password,
-    "verifypeer" : config.pserver_verifypeer,
-    "localcert" : config.pserver_localcert,
-    "cacert" : config.pserver_cacert,
-}) #: Object which will be used to speak with our pserver
-
-# anti-blocking stuff
-# I have 30 seconds to get my result or be killed
-twisted.internet.reactor.callLater(10, endBack, "timeout")
-
-# fire the reactor
-twisted.internet.reactor.callWhenRunning(myCall)
-twisted.internet.reactor.run()
-sys.exit(exitcode)
diff --git a/pulse2/services/contrib/imaging-server/hooks/end_image b/pulse2/services/contrib/imaging-server/hooks/end_image
deleted file mode 100755
index 0c67da4..0000000
--- a/pulse2/services/contrib/imaging-server/hooks/end_image
+++ /dev/null
@@ -1,188 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8; -*-
-#
-# (c) 2010 Mandriva, http://www.mandriva.com
-#
-# $Id$
-#
-# This file is part of Pulse 2, http://pulse2.mandriva.org
-#
-# Pulse 2 is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# Pulse 2 is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Pulse 2. If not, see <http://www.gnu.org/licenses/>.
-#
-
-"""
-    This is a generic hook skeleton to be used with pulse 2 imaging server
-"""
-import sys
-import twisted.internet.reactor
-import logging
-import logging.config
-from mmc.site import mmcconfdir
-import pulse2.apis.clients.imaging
-import pulse2.imaging_server.config
-import pulse2.utils
-import os.path
-
-CONFIG_FILE = mmcconfdir + '/pulse2/imaging-server/imaging-server.ini' #: config file location
-
-# default error code
-ERROR_OK = 0        #: no error
-ERROR_SERVER = 1    #: error server-side
-ERROR_CLIENT = 2    #: error client-side (here)
-ERROR_UNKNOWN = 3   #: unknow (and default) error
-exitcode = ERROR_UNKNOWN #: global error code, used when exiting
-
-########################################################################
-#         NOTHING SHOULD BE ALTERED ABOVE THIS LINE                    #
-########################################################################
-
-
-def myCall():
-    """
-        Design your own call here
-
-        a deferred should be passed to callFunction()
-    """
-    global exitcode
-
-    mac = '' # client MAC address
-    uuid = '' # image uuid
-
-    if len(sys.argv) != 3: # not enough (or too much) args
-        logging.getLogger().error('HOOK %s : I was not called with the right number of arguments (two expected, got %d)' % (sys.argv[0], len(sys.argv) - 1))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    mac = sys.argv[1]
-
-    if not pulse2.utils.isMACAddress(mac):
-        logging.getLogger().error('HOOK %s : First arg (%s) do not seems to be a MAC address' % (sys.argv[0], mac))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    uuid = sys.argv[2]
-
-    if not pulse2.utils.isUUID(uuid):
-        logging.getLogger().error('HOOK %s : Second argument is not a uuid (%s), giving up' % (sys.argv[0], sys.argv[2]))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    try:
-        callFunction(imagingAPI.imageDone(mac, uuid))
-    except AttributeError, e:
-        logging.getLogger().error('HOOK %s : %s' % (sys.argv[0], e))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-
-def myTreatment(result):
-    """
-        Design your own treatment here
-
-        don't forget to set exitcode and finally call endBack()
-    """
-    global exitcode
-    if result and result != None:
-        exitcode= ERROR_OK
-        logging.getLogger().info('HOOK %s : SUCCESS !' % sys.argv[0])
-    else:
-        exitcode = ERROR_SERVER
-        logging.getLogger().error('HOOK %s : Error server side !' % sys.argv[0])
-
-    # nothing else to do
-    return endBack()
-
-########################################################################
-#         NOTHING SHOULD BE ALTERED BELOW THIS LINE                    #
-########################################################################
-
-
-def endBack(when = None):
-    """
-        take the reactor down
-    """
-    if when == "timeout" :
-        logging.getLogger().error('HOOK %s : Killed by a timeout' % sys.argv[0])
-    twisted.internet.reactor.callLater(0, twisted.internet.reactor.stop)
-
-
-def callBack(result):
-    """
-        XMLRPC result treatment
-
-        check if it was a success by analysing result
-        if it is a success, call myCall(result)
-        if not, exitcode is set to ERROR_SERVER then call endBack()
-    """
-
-    global exitcode
-    # if result is a list and the first arg a string and its value,
-    # 'PULSE2_ERR', then something went wrong
-    if type(result) == list and len(result) > 0 and type(result[0]) == str and result[0] == 'PULSE2_ERR':
-        logging.getLogger().error("HOOK %s : Error code = %d (see previous line)" % (sys.argv[0], result[1]))
-        exitcode = ERROR_SERVER
-        return endBack()
-    else:
-        logging.getLogger().debug("%s : No error" % (sys.argv[0]))
-        exitcode = ERROR_CLIENT
-        myTreatment(result)
-
-
-def errorBack(reason):
-    """
-        XMLRPC error treatment
-
-        just set exitcode to ERROR_CLIENT then call endBack()
-    """
-    global exitcode
-    exitcode = ERROR_CLIENT
-    return endBack()
-
-
-def callFunction(deffered):
-    """
-        XMLRPC request handling
-
-        attach callBack() and errorBack() to the deferred
-    """
-    deffered.addCallbacks( # deferred handling
-        callBack,
-        errorBack)
-
-# Parse the command line
-config = pulse2.imaging_server.config.ImagingConfig() #: ConfigParser object
-config.setup(CONFIG_FILE)
-logging.config.fileConfig(CONFIG_FILE)
-
-# Instanciate the API
-imagingAPI = pulse2.apis.clients.imaging.ImagingApi({
-    "server" : config.pserver_host,
-    "port" : config.pserver_port,
-    "mountpoint" : config.pserver_mount_point,
-    "enablessl" : config.pserver_enablessl,
-    "username" : config.pserver_username,
-    "password" : config.pserver_password,
-    "verifypeer" : config.pserver_verifypeer,
-    "localcert" : config.pserver_localcert,
-    "cacert" : config.pserver_cacert,
-}) #: Object which will be used to speak with our pserver
-
-# anti-blocking stuff
-# I have 30 seconds to get my result or be killed
-twisted.internet.reactor.callLater(10, endBack, "timeout")
-
-# fire the reactor
-twisted.internet.reactor.callWhenRunning(myCall)
-twisted.internet.reactor.run()
-sys.exit(exitcode)
diff --git a/pulse2/services/contrib/imaging-server/hooks/generic_hook.py b/pulse2/services/contrib/imaging-server/hooks/generic_hook.py
deleted file mode 100644
index 800457c..0000000
--- a/pulse2/services/contrib/imaging-server/hooks/generic_hook.py
+++ /dev/null
@@ -1,168 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8; -*-
-#
-# (c) 2010 Mandriva, http://www.mandriva.com
-#
-# $Id$
-#
-# This file is part of Pulse 2, http://pulse2.mandriva.org
-#
-# Pulse 2 is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# Pulse 2 is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Pulse 2. If not, see <http://www.gnu.org/licenses/>.
-#
-
-"""
-    This is a generic hook skeleton to be used with pulse 2 imaging server
-"""
-import sys
-import twisted.internet.reactor
-import logging
-import logging.config
-import pulse2.apis.clients.imaging
-import pulse2.imaging_server.config
-
-from mmc.site import mmcconfdir
-
-CONFIG_FILE = mmcconfdir + '/pulse2/imaging-server/imaging-server.ini' #: config file location
-
-# default error code
-ERROR_OK = 0        #: no error
-ERROR_SERVER = 1    #: error server-side
-ERROR_CLIENT = 2    #: error client-side (here)
-ERROR_UNKNOWN = 3   #: unknow (and default) error
-exitcode = ERROR_UNKNOWN #: global error code, used when exiting
-
-########################################################################
-#         NOTHING SHOULD BE ALTERED ABOVE THIS LINE                    #
-########################################################################
-
-
-def myCall():
-    """
-        Design your own call here
-
-        a deferred should be passed to callFunction()
-    """
-    global exitcode
-
-    try:
-        callFunction(
-            imagingAPI.imagingServerStatus(
-            )
-        )
-    except AttributeError, e:
-        logging.getLogger().error('HOOK %s : %s' % (sys.argv[0], e))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-
-def myTreatment(result):
-    """
-        Design your own treatment here
-
-        don't forget to set exitcode and finally call endBack()
-    """
-    global exitcode
-    if result and result != None:
-        exitcode= ERROR_OK
-        logging.getLogger().info('HOOK %s : SUCCESS !' % sys.argv[0])
-    else:
-        exitcode = ERROR_SERVER
-        logging.getLogger().error('HOOK %s : Error server side !' % sys.argv[0])
-
-    # nothing else to do
-    return endBack()
-
-########################################################################
-#         NOTHING SHOULD BE ALTERED BELOW THIS LINE                    #
-########################################################################
-
-
-def endBack(when = None):
-    """
-        take the reactor down
-    """
-    if when == "timeout" :
-        logging.getLogger().error('HOOK %s : Killed by a timeout' % sys.argv[0])
-    twisted.internet.reactor.callLater(0, twisted.internet.reactor.stop)
-
-
-def callBack(result):
-    """
-        XMLRPC result treatment
-
-        check if it was a success by analysing result
-        if it is a success, call myCall(result)
-        if not, exitcode is set to ERROR_SERVER then call endBack()
-    """
-
-    global exitcode
-    # if result is a list and the first arg a string and its value,
-    # 'PULSE2_ERR', then something went wrong
-    if type(result) == list and len(result) > 0 and type(result[0]) == str and result[0] == 'PULSE2_ERR':
-        logging.getLogger().error("HOOK %s : Error code = %d (see previous line)" % (sys.argv[0], result[1]))
-        exitcode = ERROR_SERVER
-        return endBack()
-    else:
-        logging.getLogger().debug("%s : No error" % (sys.argv[0]))
-        exitcode = ERROR_CLIENT
-        myTreatment(result)
-
-
-def errorBack(reason):
-    """
-        XMLRPC error treatment
-
-        just set exitcode to ERROR_CLIENT then call endBack()
-    """
-    global exitcode
-    exitcode = ERROR_CLIENT
-    return endBack()
-
-
-def callFunction(deffered):
-    """
-        XMLRPC request handling
-
-        attach callBack() and errorBack() to the deferred
-    """
-    deffered.addCallbacks( # deferred handling
-        callBack,
-        errorBack)
-
-# Parse the command line
-config = pulse2.imaging_server.config.ImagingConfig() #: ConfigParser object
-config.setup(CONFIG_FILE)
-logging.config.fileConfig(CONFIG_FILE)
-
-# Instanciate the API
-imagingAPI = pulse2.apis.clients.imaging.ImagingApi({
-    "server" : config.pserver_host,
-    "port" : config.pserver_port,
-    "mountpoint" : config.pserver_mount_point,
-    "enablessl" : config.pserver_enablessl,
-    "username" : config.pserver_username,
-    "password" : config.pserver_password,
-    "verifypeer" : config.pserver_verifypeer,
-    "localcert" : config.pserver_localcert,
-    "cacert" : config.pserver_cacert,
-}) #: Object which will be used to speak with our pserver
-
-# anti-blocking stuff
-# I have 30 seconds to get my result or be killed
-twisted.internet.reactor.callLater(10, endBack, "timeout")
-
-# fire the reactor
-twisted.internet.reactor.callWhenRunning(myCall)
-twisted.internet.reactor.run()
-sys.exit(exitcode)
diff --git a/pulse2/services/contrib/imaging-server/hooks/get_hostname b/pulse2/services/contrib/imaging-server/hooks/get_hostname
deleted file mode 100755
index cd42e1b..0000000
--- a/pulse2/services/contrib/imaging-server/hooks/get_hostname
+++ /dev/null
@@ -1,194 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8; -*-
-#
-# (c) 2010 Mandriva, http://www.mandriva.com
-#
-# $Id$
-#
-# This file is part of Pulse 2, http://pulse2.mandriva.org
-#
-# Pulse 2 is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# Pulse 2 is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Pulse 2. If not, see <http://www.gnu.org/licenses/>.
-#
-
-"""
-    This is a generic hook skeleton to be used with pulse 2 imaging server
-"""
-import sys
-import os.path
-import twisted.internet.reactor
-import logging
-import logging.config
-
-from mmc.site import mmcconfdir
-import pulse2.apis.clients.imaging
-import pulse2.imaging_server.config
-
-CONFIG_FILE = mmcconfdir + '/pulse2/imaging-server/imaging-server.ini' #: config file location
-
-# default error code
-ERROR_OK = 0        #: no error
-ERROR_SERVER = 1    #: error server-side
-ERROR_CLIENT = 2    #: error client-side (here)
-ERROR_UNKNOWN = 3   #: unknow (and default) error
-exitcode = ERROR_UNKNOWN #: global error code, used when exiting
-
-########################################################################
-#         NOTHING SHOULD BE ALTERED ABOVE THIS LINE                    #
-########################################################################
-
-
-def myCall():
-    """
-        Design your own call here
-
-        a deferred should be passed to callFunction()
-    """
-    global exitcode
-
-    if len(sys.argv) != 3: # not enough (or too much) args
-        logging.getLogger().error('HOOK %s : I was not called with the right number of arguments (two expected, got %d)' % (sys.argv[0], len(sys.argv) - 1))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    mac = sys.argv[1]
-    if not pulse2.utils.isMACAddress(mac):
-        logging.getLogger().error('HOOK %s : First arg (%s) do not seems to be a MAC address' % (sys.argv[0], mac))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    try:
-        callFunction(imagingAPI.getComputerByMac(mac))
-    except AttributeError, e:
-        logging.getLogger().error('HOOK %s : %s' % (sys.argv[0], e))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-
-def myTreatment(result):
-    """
-        Design your own treatment here
-
-        don't forget to set exitcode and finally call endBack()
-    """
-    global exitcode
-
-    if result and type(result) == dict:
-        filename = sys.argv[2]
-
-        if not os.path.isfile(filename):
-            logging.getLogger().error('HOOK %s : Second arg (%s) do not seems to be an existing file name' % (sys.argv[0], filename))
-            exitcode = ERROR_CLIENT
-            return endBack()
-
-        try:
-            filestream = open(filename, 'w')
-            filestream.write(result['shortname'])
-            filestream.close()
-        except Exception, e:
-            logging.getLogger().error('HOOK %s : Can\'t write %s : %s, giving up' % (sys.argv[0], filename, e))
-            exitcode = ERROR_CLIENT
-            return endBack()
-
-        exitcode = ERROR_OK
-        logging.getLogger().info('HOOK %s : SUCCESS !' % sys.argv[0])
-    else:
-        exitcode = ERROR_SERVER
-        logging.getLogger().error('HOOK %s : Error server side !' % sys.argv[0])
-
-    # nothing else to do
-    return endBack()
-
-########################################################################
-#         NOTHING SHOULD BE ALTERED BELOW THIS LINE                    #
-########################################################################
-
-
-def endBack(when=None):
-    """
-        take the reactor down
-    """
-    if when == "timeout":
-        logging.getLogger().error('HOOK %s : Killed by a timeout' % sys.argv[0])
-    twisted.internet.reactor.callLater(0, twisted.internet.reactor.stop)
-
-
-def callBack(result):
-    """
-        XMLRPC result treatment
-
-        check if it was a success by analysing result
-        if it is a success, call myCall(result)
-        if not, exitcode is set to ERROR_SERVER then call endBack()
-    """
-
-    global exitcode
-    # if result is a list and the first arg a string and its value,
-    # 'PULSE2_ERR', then something went wrong
-    if type(result) == list and len(result) > 0 and type(result[0]) == str and result[0] == 'PULSE2_ERR':
-        logging.getLogger().error("HOOK %s : Error code = %d (see previous line)" % (sys.argv[0], result[1]))
-        exitcode = ERROR_SERVER
-        return endBack()
-    else:
-        logging.getLogger().debug("%s : No error" % (sys.argv[0]))
-        exitcode = ERROR_CLIENT
-        myTreatment(result)
-
-
-def errorBack(reason):
-    """
-        XMLRPC error treatment
-
-        just set exitcode to ERROR_CLIENT then call endBack()
-    """
-    global exitcode
-    exitcode = ERROR_CLIENT
-    return endBack()
-
-
-def callFunction(deffered):
-    """
-        XMLRPC request handling
-
-        attach callBack() and errorBack() to the deferred
-    """
-    deffered.addCallbacks( # deferred handling
-        callBack,
-        errorBack)
-
-# Parse the command line
-config = pulse2.imaging_server.config.ImagingConfig() #: ConfigParser object
-config.setup(CONFIG_FILE)
-logging.config.fileConfig(CONFIG_FILE)
-
-# Instanciate the API
-imagingAPI = pulse2.apis.clients.imaging.ImagingApi({
-    "server": config.pserver_host,
-    "port": config.pserver_port,
-    "mountpoint": config.pserver_mount_point,
-    "enablessl": config.pserver_enablessl,
-    "username": config.pserver_username,
-    "password": config.pserver_password,
-    "verifypeer": config.pserver_verifypeer,
-    "localcert": config.pserver_localcert,
-    "cacert": config.pserver_cacert,
-}) #: Object which will be used to speak with our pserver
-
-# anti-blocking stuff
-# I have 30 seconds to get my result or be killed
-twisted.internet.reactor.callLater(10, endBack, "timeout")
-
-# fire the reactor
-twisted.internet.reactor.callWhenRunning(myCall)
-twisted.internet.reactor.run()
-sys.exit(exitcode)
diff --git a/pulse2/services/contrib/imaging-server/hooks/get_uuid b/pulse2/services/contrib/imaging-server/hooks/get_uuid
deleted file mode 100755
index c5f725e..0000000
--- a/pulse2/services/contrib/imaging-server/hooks/get_uuid
+++ /dev/null
@@ -1,194 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8; -*-
-#
-# (c) 2010 Mandriva, http://www.mandriva.com
-#
-# $Id$
-#
-# This file is part of Pulse 2, http://pulse2.mandriva.org
-#
-# Pulse 2 is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# Pulse 2 is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Pulse 2. If not, see <http://www.gnu.org/licenses/>.
-#
-
-"""
-    This is a generic hook skeleton to be used with pulse 2 imaging server
-"""
-import sys
-import os.path
-import twisted.internet.reactor
-import logging
-import logging.config
-
-from mmc.site import mmcconfdir
-import pulse2.apis.clients.imaging
-import pulse2.imaging_server.config
-
-CONFIG_FILE = mmcconfdir + '/pulse2/imaging-server/imaging-server.ini' #: config file location
-
-# default error code
-ERROR_OK = 0        #: no error
-ERROR_SERVER = 1    #: error server-side
-ERROR_CLIENT = 2    #: error client-side (here)
-ERROR_UNKNOWN = 3   #: unknow (and default) error
-exitcode = ERROR_UNKNOWN #: global error code, used when exiting
-
-########################################################################
-#         NOTHING SHOULD BE ALTERED ABOVE THIS LINE                    #
-########################################################################
-
-
-def myCall():
-    """
-        Design your own call here
-
-        a deferred should be passed to callFunction()
-    """
-    global exitcode
-
-    if len(sys.argv) != 3: # not enough (or too much) args
-        logging.getLogger().error('HOOK %s : I was not called with the right number of arguments (two expected, got %d)' % (sys.argv[0], len(sys.argv) - 1))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    mac = sys.argv[1]
-    if not pulse2.utils.isMACAddress(mac):
-        logging.getLogger().error('HOOK %s : First arg (%s) do not seems to be a MAC address' % (sys.argv[0], mac))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    try:
-        callFunction(imagingAPI.getComputerByMac(mac))
-    except AttributeError, e:
-        logging.getLogger().error('HOOK %s : %s' % (sys.argv[0], e))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-
-def myTreatment(result):
-    """
-        Design your own treatment here
-
-        don't forget to set exitcode and finally call endBack()
-    """
-    global exitcode
-
-    if result and type(result) == dict:
-        filename = sys.argv[2]
-
-        if not os.path.isfile(filename):
-            logging.getLogger().error('HOOK %s : Second arg (%s) do not seems to be an existing file name' % (sys.argv[0], filename))
-            exitcode = ERROR_CLIENT
-            return endBack()
-
-        try :
-            filestream = open(filename, 'w')
-            filestream.write(result['uuid'])
-            filestream.close()
-        except Exception, e:
-            logging.getLogger().error('HOOK %s : Can\'t write %s : %s, giving up' % (sys.argv[0], filename, e))
-            exitcode = ERROR_CLIENT
-            return endBack()
-
-        exitcode= ERROR_OK
-        logging.getLogger().info('HOOK %s : SUCCESS !' % sys.argv[0])
-    else:
-        exitcode = ERROR_SERVER
-        logging.getLogger().error('HOOK %s : Error server side !' % sys.argv[0])
-
-    # nothing else to do
-    return endBack()
-
-########################################################################
-#         NOTHING SHOULD BE ALTERED BELOW THIS LINE                    #
-########################################################################
-
-
-def endBack(when = None):
-    """
-        take the reactor down
-    """
-    if when == "timeout" :
-        logging.getLogger().error('HOOK %s : Killed by a timeout' % sys.argv[0])
-    twisted.internet.reactor.callLater(0, twisted.internet.reactor.stop)
-
-
-def callBack(result):
-    """
-        XMLRPC result treatment
-
-        check if it was a success by analysing result
-        if it is a success, call myCall(result)
-        if not, exitcode is set to ERROR_SERVER then call endBack()
-    """
-
-    global exitcode
-    # if result is a list and the first arg a string and its value,
-    # 'PULSE2_ERR', then something went wrong
-    if type(result) == list and len(result) > 0 and type(result[0]) == str and result[0] == 'PULSE2_ERR':
-        logging.getLogger().error("HOOK %s : Error code = %d (see previous line)" % (sys.argv[0], result[1]))
-        exitcode = ERROR_SERVER
-        return endBack()
-    else:
-        logging.getLogger().debug("%s : No error" % (sys.argv[0]))
-        exitcode = ERROR_CLIENT
-        myTreatment(result)
-
-
-def errorBack(reason):
-    """
-        XMLRPC error treatment
-
-        just set exitcode to ERROR_CLIENT then call endBack()
-    """
-    global exitcode
-    exitcode = ERROR_CLIENT
-    return endBack()
-
-
-def callFunction(deffered):
-    """
-        XMLRPC request handling
-
-        attach callBack() and errorBack() to the deferred
-    """
-    deffered.addCallbacks( # deferred handling
-        callBack,
-        errorBack)
-
-# Parse the command line
-config = pulse2.imaging_server.config.ImagingConfig() #: ConfigParser object
-config.setup(CONFIG_FILE)
-logging.config.fileConfig(CONFIG_FILE)
-
-# Instanciate the API
-imagingAPI = pulse2.apis.clients.imaging.ImagingApi({
-    "server" : config.pserver_host,
-    "port" : config.pserver_port,
-    "mountpoint" : config.pserver_mount_point,
-    "enablessl" : config.pserver_enablessl,
-    "username" : config.pserver_username,
-    "password" : config.pserver_password,
-    "verifypeer" : config.pserver_verifypeer,
-    "localcert" : config.pserver_localcert,
-    "cacert" : config.pserver_cacert,
-}) #: Object which will be used to speak with our pserver
-
-# anti-blocking stuff
-# I have 30 seconds to get my result or be killed
-twisted.internet.reactor.callLater(10, endBack, "timeout")
-
-# fire the reactor
-twisted.internet.reactor.callWhenRunning(myCall)
-twisted.internet.reactor.run()
-sys.exit(exitcode)
diff --git a/pulse2/services/contrib/imaging-server/hooks/log_action b/pulse2/services/contrib/imaging-server/hooks/log_action
deleted file mode 100755
index 3e56551..0000000
--- a/pulse2/services/contrib/imaging-server/hooks/log_action
+++ /dev/null
@@ -1,187 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8; -*-
-#
-# (c) 2010 Mandriva, http://www.mandriva.com
-#
-# $Id$
-#
-# This file is part of Pulse 2, http://pulse2.mandriva.org
-#
-# Pulse 2 is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# Pulse 2 is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Pulse 2. If not, see <http://www.gnu.org/licenses/>.
-#
-
-"""
-    This is a generic hook skeleton to be used with pulse 2 imaging server
-"""
-import sys
-import twisted.internet.reactor
-import logging
-import logging.config
-from mmc.site import mmcconfdir
-import pulse2.apis.clients.imaging
-import pulse2.imaging_server.config
-
-CONFIG_FILE = mmcconfdir + '/pulse2/imaging-server/imaging-server.ini' #: config file location
-
-# default error code
-ERROR_OK = 0        #: no error
-ERROR_SERVER = 1    #: error server-side
-ERROR_CLIENT = 2    #: error client-side (here)
-ERROR_UNKNOWN = 3   #: unknow (and default) error
-exitcode = ERROR_UNKNOWN #: global error code, used when exiting
-
-########################################################################
-#         NOTHING SHOULD BE ALTERED ABOVE THIS LINE                    #
-########################################################################
-
-
-def myCall():
-    """
-        Design your own call here
-
-        a deferred should be passed to callFunction()
-    """
-    global exitcode
-
-    if len(sys.argv) != 5: # not enough (or too much) args
-        logging.getLogger().error('HOOK %s : I was not called with the right number of arguments (four expected, got %d)' % (sys.argv[0], len(sys.argv) - 1))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    mac = sys.argv[1]
-    if not pulse2.utils.isMACAddress(mac):
-        logging.getLogger().error('HOOK %s : First arg (%s) do not seems to be a MAC address' % (sys.argv[0], mac))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    try:
-        level = int(sys.argv[2])
-        level += 1 # shift log level by one
-    except ValueError:
-        logging.getLogger().error('HOOK %s : Second arg (%s) do not seems to be an integer' % (sys.argv[0], sys.argv[2]))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    phase = sys.argv[3]
-
-    message = sys.argv[4]
-
-    try:
-        callFunction(imagingAPI.logClientAction(mac, level, phase, message))
-    except AttributeError, e:
-        logging.getLogger().error('HOOK %s : %s' % (sys.argv[0], e))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-
-def myTreatment(result):
-    """
-        Design your own treatment here
-
-        don't forget to set exitcode and finally call endBack()
-    """
-    global exitcode
-    if result and result != None:
-        exitcode= ERROR_OK
-        logging.getLogger().info('HOOK %s : SUCCESS !' % sys.argv[0])
-    else:
-        exitcode = ERROR_SERVER
-        logging.getLogger().error('HOOK %s : Error server side !' % sys.argv[0])
-
-    # nothing else to do
-    return endBack()
-
-########################################################################
-#         NOTHING SHOULD BE ALTERED BELOW THIS LINE                    #
-########################################################################
-
-
-def endBack(when = None):
-    """
-        take the reactor down
-    """
-    if when == "timeout" :
-        logging.getLogger().error('HOOK %s : Killed by a timeout' % sys.argv[0])
-    twisted.internet.reactor.callLater(0, twisted.internet.reactor.stop)
-
-
-def callBack(result):
-    """
-        XMLRPC result treatment
-
-        check if it was a success by analysing result
-        if it is a success, call myCall(result)
-        if not, exitcode is set to ERROR_SERVER then call endBack()
-    """
-
-    global exitcode
-    # if result is a list and the first arg a string and its value,
-    # 'PULSE2_ERR', then something went wrong
-    if type(result) == list and len(result) > 0 and type(result[0]) == str and result[0] == 'PULSE2_ERR':
-        logging.getLogger().error("HOOK %s : Error code = %d (see previous line)" % (sys.argv[0], result[1]))
-        exitcode = ERROR_SERVER
-        return endBack()
-    else:
-        logging.getLogger().debug("%s : No error" % (sys.argv[0]))
-        exitcode = ERROR_CLIENT
-        myTreatment(result)
-
-
-def errorBack(reason):
-    """
-        XMLRPC error treatment
-
-        just set exitcode to ERROR_CLIENT then call endBack()
-    """
-    global exitcode
-    exitcode = ERROR_CLIENT
-    return endBack()
-
-
-def callFunction(deffered):
-    """
-        XMLRPC request handling
-
-        attach callBack() and errorBack() to the deferred
-    """
-    deffered.addCallbacks( # deferred handling
-        callBack,
-        errorBack)
-
-# Parse the command line
-config = pulse2.imaging_server.config.ImagingConfig() #: ConfigParser object
-config.setup(CONFIG_FILE)
-logging.config.fileConfig(CONFIG_FILE)
-
-# Instanciate the API
-imagingAPI = pulse2.apis.clients.imaging.ImagingApi({
-    "server" : config.pserver_host,
-    "port" : config.pserver_port,
-    "mountpoint" : config.pserver_mount_point,
-    "enablessl" : config.pserver_enablessl,
-    "username" : config.pserver_username,
-    "password" : config.pserver_password,
-    "verifypeer" : config.pserver_verifypeer,
-    "localcert" : config.pserver_localcert,
-    "cacert" : config.pserver_cacert,
-}) #: Object which will be used to speak with our pserver
-
-# anti-blocking stuff
-# I have 30 seconds to get my result or be killed
-twisted.internet.reactor.callLater(10, endBack, "timeout")
-
-# fire the reactor
-twisted.internet.reactor.callWhenRunning(myCall)
-twisted.internet.reactor.run()
-sys.exit(exitcode)
diff --git a/pulse2/services/contrib/imaging-server/hooks/mtftp_sync b/pulse2/services/contrib/imaging-server/hooks/mtftp_sync
deleted file mode 100755
index 65b3ca0..0000000
--- a/pulse2/services/contrib/imaging-server/hooks/mtftp_sync
+++ /dev/null
@@ -1,167 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8; -*-
-#
-# (c) 2010 Mandriva, http://www.mandriva.com
-#
-# $Id$
-#
-# This file is part of Pulse 2, http://pulse2.mandriva.org
-#
-# Pulse 2 is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# Pulse 2 is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Pulse 2. If not, see <http://www.gnu.org/licenses/>.
-#
-
-"""
-    This is a generic hook skeleton to be used with pulse 2 imaging server
-"""
-import sys
-import twisted.internet.reactor
-import logging
-import logging.config
-from mmc.site import mmcconfdir
-import pulse2.apis.clients.imaging
-import pulse2.imaging_server.config
-
-CONFIG_FILE = mmcconfdir + '/pulse2/imaging-server/imaging-server.ini' #: config file location
-
-# default error code
-ERROR_OK = 0        #: no error
-ERROR_SERVER = 1    #: error server-side
-ERROR_CLIENT = 2    #: error client-side (here)
-ERROR_UNKNOWN = 3   #: unknow (and default) error
-exitcode = ERROR_UNKNOWN #: global error code, used when exiting
-
-########################################################################
-#         NOTHING SHOULD BE ALTERED ABOVE THIS LINE                    #
-########################################################################
-
-
-def myCall():
-    """
-        Design your own call here
-
-        a deferred should be passed to callFunction()
-    """
-    global exitcode
-
-    try:
-        callFunction(
-            imagingAPI.imagingServerStatus(
-            )
-        )
-    except AttributeError, e:
-        logging.getLogger().error('HOOK %s : %s' % (sys.argv[0], e))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-
-def myTreatment(result):
-    """
-        Design your own treatment here
-
-        don't forget to set exitcode and finally call endBack()
-    """
-    global exitcode
-    if result and result != None:
-        exitcode= ERROR_OK
-        logging.getLogger().info('HOOK %s : SUCCESS !' % sys.argv[0])
-    else:
-        exitcode = ERROR_SERVER
-        logging.getLogger().error('HOOK %s : Error server side !' % sys.argv[0])
-
-    # nothing else to do
-    return endBack()
-
-########################################################################
-#         NOTHING SHOULD BE ALTERED BELOW THIS LINE                    #
-########################################################################
-
-
-def endBack(when = None):
-    """
-        take the reactor down
-    """
-    if when == "timeout" :
-        logging.getLogger().error('HOOK %s : Killed by a timeout' % sys.argv[0])
-    twisted.internet.reactor.callLater(0, twisted.internet.reactor.stop)
-
-
-def callBack(result):
-    """
-        XMLRPC result treatment
-
-        check if it was a success by analysing result
-        if it is a success, call myCall(result)
-        if not, exitcode is set to ERROR_SERVER then call endBack()
-    """
-
-    global exitcode
-    # if result is a list and the first arg a string and its value,
-    # 'PULSE2_ERR', then something went wrong
-    if type(result) == list and len(result) > 0 and type(result[0]) == str and result[0] == 'PULSE2_ERR':
-        logging.getLogger().error("HOOK %s : Error code = %d (see previous line)" % (sys.argv[0], result[1]))
-        exitcode = ERROR_SERVER
-        return endBack()
-    else:
-        logging.getLogger().debug("%s : No error" % (sys.argv[0]))
-        exitcode = ERROR_CLIENT
-        myTreatment(result)
-
-
-def errorBack(reason):
-    """
-        XMLRPC error treatment
-
-        just set exitcode to ERROR_CLIENT then call endBack()
-    """
-    global exitcode
-    exitcode = ERROR_CLIENT
-    return endBack()
-
-
-def callFunction(deffered):
-    """
-        XMLRPC request handling
-
-        attach callBack() and errorBack() to the deferred
-    """
-    deffered.addCallbacks( # deferred handling
-        callBack,
-        errorBack)
-
-# Parse the command line
-config = pulse2.imaging_server.config.ImagingConfig() #: ConfigParser object
-config.setup(CONFIG_FILE)
-logging.config.fileConfig(CONFIG_FILE)
-
-# Instanciate the API
-imagingAPI = pulse2.apis.clients.imaging.ImagingApi({
-    "server" : config.pserver_host,
-    "port" : config.pserver_port,
-    "mountpoint" : config.pserver_mount_point,
-    "enablessl" : config.pserver_enablessl,
-    "username" : config.pserver_username,
-    "password" : config.pserver_password,
-    "verifypeer" : config.pserver_verifypeer,
-    "localcert" : config.pserver_localcert,
-    "cacert" : config.pserver_cacert,
-}) #: Object which will be used to speak with our pserver
-
-# anti-blocking stuff
-# I have 30 seconds to get my result or be killed
-twisted.internet.reactor.callLater(10, endBack, "timeout")
-
-# fire the reactor
-twisted.internet.reactor.callWhenRunning(myCall)
-twisted.internet.reactor.run()
-sys.exit(exitcode)
diff --git a/pulse2/services/contrib/imaging-server/hooks/process_inventory b/pulse2/services/contrib/imaging-server/hooks/process_inventory
deleted file mode 100755
index 233fbd9..0000000
--- a/pulse2/services/contrib/imaging-server/hooks/process_inventory
+++ /dev/null
@@ -1,367 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8; -*-
-#
-# (c) 2010 Mandriva, http://www.mandriva.com
-#
-# $Id$
-#
-# This file is part of Pulse 2, http://pulse2.mandriva.org
-#
-# Pulse 2 is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# Pulse 2 is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Pulse 2. If not, see <http://www.gnu.org/licenses/>.
-#
-
-"""
-    This is a generic hook skeleton to be used with pulse 2 imaging server
-"""
-import sys
-import os.path
-from twisted.internet import reactor
-from twisted.internet.defer import succeed
-from twisted.web.client import Agent
-from twisted.web.http_headers import Headers
-from twisted.web.iweb import IBodyProducer
-from zope.interface import implements
-import logging
-import logging.config
-
-from mmc.site import mmcconfdir
-import pulse2.apis.clients.imaging
-import pulse2.imaging_server.config
-import pulse2.imaging.bootinventory
-
-CONFIG_FILE = mmcconfdir + '/pulse2/imaging-server/imaging-server.ini' #: config file location
-
-# default error code
-ERROR_OK = 0        #: no error
-ERROR_SERVER = 1    #: error server-side
-ERROR_CLIENT = 2    #: error client-side (here)
-ERROR_UNKNOWN = 3   #: unknow (and default) error
-exitcode = ERROR_UNKNOWN #: global error code, used when exiting
-mac = ''            # client MAC address
-
-########################################################################
-#         NOTHING SHOULD BE ALTERED ABOVE THIS LINE                    #
-########################################################################
-
-def loadInventory():
-    """
-        Load the PXE inventory from file
-    """
-
-    global exitcode
-    global mac
-
-    filename = '' # where the inventory is temporaly stored
-    filestream = None
-    data = None     # will hold our inventory (text)
-    inventory = {}  # will hold our inventory (struct)
-
-    if len(sys.argv) != 3: # not enough (or too much) args
-        logging.getLogger().error('HOOK %s : I was not called with the right number of arguments (two expected, got %d)' % (sys.argv[0], len(sys.argv) - 1))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    mac = sys.argv[1]
-
-    if not pulse2.utils.isMACAddress(mac):
-        logging.getLogger().error('HOOK %s : First arg (%s) do not seems to be a MAC address' % (sys.argv[0], mac))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    filename = sys.argv[2]
-
-    if not os.path.isfile(filename):
-        logging.getLogger().error('HOOK %s : Second arg (%s) do not seems to be an existing file name' % (sys.argv[0], filename))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    try :
-        filestream = open(filename)
-        data = filestream.readlines()
-        filestream.close()
-    except:
-        logging.getLogger().error('HOOK %s : Can\'t read %s, giving up' % (sys.argv[0], filename))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    inventory = pulse2.imaging.bootinventory.BootInventory(data)
-
-    return inventory
-
-def myImagingCall():
-    """
-        Design your own call here
-
-        a deferred should be passed to callImaging()
-    """
-    global exitcode
-    global mac
-
-    try:
-        inventory = loadInventory()
-        callImaging(imagingAPI.injectInventory(mac, inventory.dump()))
-    except AttributeError, e:
-        logging.getLogger().error('HOOK %s : %s' % (sys.argv[0], e))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-def myImagingResult(result):
-    """
-        Design your own treatment here
-
-        don't forget to set exitcode and finally call endBack()
-    """
-    global exitcode
-
-    if result and result != None:
-        exitcode = ERROR_OK
-        logging.getLogger().info('HOOK %s : SUCCESS (imaging OK)' % sys.argv[0])
-    else:
-        exitcode = ERROR_SERVER
-        logging.getLogger().error('HOOK %s : Error (imaging NOK)' % sys.argv[0])
-
-    reactor.callLater(0, myHostnameCall)
-
-def myHostnameCall():
-    """
-        Get the hostname of the client
-    """
-
-    global exitcode
-    global mac
-
-    try:
-        callImagingHostname(imagingAPI.getComputerByMac(mac))
-    except AttributeError, e:
-        logging.getLogger().error('HOOK %s : %s' % (sys.argv[0], e))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-def myImagingHostnameResult(result):
-    """
-        Design your own treatment here
-
-        don't forget to set exitcode and finally call endBack()
-    """
-    global exitcode
-
-    logging.getLogger().debug("HOOK %s : Get hostname result: %s" % (sys.argv[0], str(result)))
-
-    if result and result != None:
-        exitcode = ERROR_OK
-
-    reactor.callLater(0, myInventoryCall, result)
-
-def myInventoryCall(computer):
-
-    """
-        Send an OCS like inventory to the inventory-server
-    """
-
-    global exitcode
-
-    inventory = loadInventory()
-    inventory = inventory.dumpOCS(computer['shortname'], computer['entity'])
-
-    logging.getLogger().debug('%s : About to send the inventory to the inventory server' % sys.argv[0])
-
-    agent = Agent(reactor)
-    url = "http://%s:%s/"
-    if config.invserver_enablessl:
-        url = "https://%s:%s/"
-    # POST the inventory to the inventory server
-    class StringProducer(object):
-        implements(IBodyProducer)
-
-        def __init__(self, string):
-            self.body = string
-            self.length = len(self.body)
-
-        def startProducing(self, consumer):
-            consumer.write(self.body)
-            return succeed(None)
-
-    d = agent.request('POST',
-                      url % (config.invserver_host, config.invserver_port),
-                      Headers({
-                        'Content-Type': ['application/x-www-form-urlencoded'],
-                        'Content-Length': [str(len(inventory))],
-                        'User-Agent': ['Pulse2 Imaging server inventory hook']
-                      }),
-                      StringProducer(inventory),
-                     )
-    callInventory(d)
-
-
-def myInventoryResult(result):
-
-    global exitcode
-
-    if result and result != None:
-        exitcode = ERROR_OK
-        logging.getLogger().info('HOOK %s : SUCCESS (inventory OK)' % sys.argv[0])
-    else:
-        exitcode = ERROR_SERVER
-        logging.getLogger().error('HOOK %s : Error (inventory NOK)' % sys.argv[0])
-
-    # nothing more to do
-    return endBack()
-
-
-########################################################################
-#         NOTHING SHOULD BE ALTERED BELOW THIS LINE                    #
-########################################################################
-
-
-def endBack(when = None):
-    """
-        Take the reactor down
-    """
-    if when == "timeout" :
-        logging.getLogger().error('HOOK %s : Killed by a timeout' % sys.argv[0])
-    reactor.callLater(0, reactor.stop)
-
-
-def errorBack(reason):
-    """
-        XMLRPC error treatment
-
-        just set exitcode to ERROR_CLIENT then call endBack()
-    """
-    global exitcode
-    logging.getLogger().error("HOOK %s : Failed. Exiting." % sys.argv[0])
-    exitcode = ERROR_CLIENT
-    return endBack()
-
-
-def callImaging(deffered):
-    """
-        XMLRPC request handling
-
-        attach callBackImaging() and errorBack() to the deferred
-    """
-    deffered.addCallbacks( # deferred handling
-        callBackImaging,
-        errorBack)
-
-def callBackImaging(result):
-    """
-        XMLRPC result treatment
-
-        check if it was a success by analysing result
-        if it is a success, call myImagingResult(result)
-        if not, exitcode is set to ERROR_SERVER then call endBack()
-    """
-
-    global exitcode
-    # if result is a list and the first arg a string and its value,
-    # 'PULSE2_ERR', then something went wrong
-    if type(result) == list and len(result) > 0 and type(result[0]) == str and result[0] == 'PULSE2_ERR':
-        logging.getLogger().error("HOOK %s : Error code = %d (see previous line)" % (sys.argv[0], result[1]))
-        exitcode = ERROR_SERVER
-        return endBack()
-    else:
-        logging.getLogger().debug("%s : PXE Inventory sent" % (sys.argv[0]))
-        exitcode = ERROR_CLIENT
-        myImagingResult(result)
-
-def callImagingHostname(deffered):
-    """
-        XMLRPC request handling
-
-        attach callBackImagingHostname() and errorBack() to the deferred
-    """
-    deffered.addCallbacks( # deferred handling
-        callBackImagingHostname,
-        errorBack)
-
-def callBackImagingHostname(result):
-    """
-        XMLRPC result treatment
-
-        check if it was a success by analysing result
-        if it is a success, call myImagingHostnameResult(result)
-        if not, exitcode is set to ERROR_SERVER then call endBack()
-    """
-
-    global exitcode
-    # if result is a list and the first arg a string and its value,
-    # 'PULSE2_ERR', then something went wrong
-    if type(result) == list and len(result) > 0 and type(result[0]) == str and result[0] == 'PULSE2_ERR':
-        logging.getLogger().error("HOOK %s : Error code = %d (see previous line)" % (sys.argv[0], result[1]))
-        exitcode = ERROR_SERVER
-        return endBack()
-    else:
-        logging.getLogger().debug("%s : Hostname received" % (sys.argv[0]))
-        exitcode = ERROR_CLIENT
-        myImagingHostnameResult(result)
-
-def callInventory(deffered):
-    """
-        HTTP request handling
-
-        attach callBackInventory() and errorBack() to the deferred
-    """
-    deffered.addCallbacks(
-        callBackInventory,
-        errorBack)
-
-def callBackInventory(result):
-    """
-        HTTP request result treatment
-
-        check if it was a success by analysing result
-        if it is a success, call myInventoryResult(result)
-        if not, exitcode is set to ERROR_SERVER then call endBack()
-    """
-
-    global exitcode
-
-    if result.code != 200:
-        logging.getLogger().error("HOOK %s : Error sending the inventory to the inventory server" % sys.argv[0])
-        logging.getLogger().error(result.phrase)
-        exitcode = ERROR_SERVER
-        return endBack()
-    else:
-        logging.getLogger().debug("%s : Inventory sent to the inventory server" % sys.argv[0])
-        exitcode = ERROR_CLIENT
-        myInventoryResult(result)
-
-
-# Parse the command line
-config = pulse2.imaging_server.config.ImagingConfig() #: ConfigParser object
-config.setup(CONFIG_FILE)
-logging.config.fileConfig(CONFIG_FILE)
-
-# Instanciate the API
-imagingAPI = pulse2.apis.clients.imaging.ImagingApi({
-    "server" : config.pserver_host,
-    "port" : config.pserver_port,
-    "mountpoint" : config.pserver_mount_point,
-    "enablessl" : config.pserver_enablessl,
-    "username" : config.pserver_username,
-    "password" : config.pserver_password,
-    "verifypeer" : config.pserver_verifypeer,
-    "localcert" : config.pserver_localcert,
-    "cacert" : config.pserver_cacert,
-}) #: Object which will be used to speak with our pserver
-
-# anti-blocking stuff
-# I have 30 seconds to get my result or be killed
-reactor.callLater(30, endBack, "timeout")
-
-# fire the reactor
-reactor.callWhenRunning(myImagingCall)
-reactor.run()
-sys.exit(exitcode)
diff --git a/pulse2/services/contrib/imaging-server/hooks/start_image b/pulse2/services/contrib/imaging-server/hooks/start_image
deleted file mode 100755
index 263bb48..0000000
--- a/pulse2/services/contrib/imaging-server/hooks/start_image
+++ /dev/null
@@ -1,196 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8; -*-
-#
-# (c) 2010 Mandriva, http://www.mandriva.com
-#
-# $Id$
-#
-# This file is part of Pulse 2, http://pulse2.mandriva.org
-#
-# Pulse 2 is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# Pulse 2 is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Pulse 2. If not, see <http://www.gnu.org/licenses/>.
-#
-
-"""
-    This is a generic hook skeleton to be used with pulse 2 imaging server
-"""
-import sys
-import os.path
-import twisted.internet.reactor
-import logging
-import logging.config
-
-from mmc.site import mmcconfdir
-import pulse2.apis.clients.imaging
-import pulse2.imaging_server.config
-import pulse2.utils
-
-CONFIG_FILE = mmcconfdir + '/pulse2/imaging-server/imaging-server.ini' #: config file location
-
-# default error code
-ERROR_OK = 0        #: no error
-ERROR_SERVER = 1    #: error server-side
-ERROR_CLIENT = 2    #: error client-side (here)
-ERROR_UNKNOWN = 3   #: unknow (and default) error
-exitcode = ERROR_UNKNOWN #: global error code, used when exiting
-
-########################################################################
-#         NOTHING SHOULD BE ALTERED ABOVE THIS LINE                    #
-########################################################################
-
-
-def myCall():
-    """
-        Design your own call here
-
-        a deferred should be passed to callFunction()
-    """
-    global exitcode
-
-    if len(sys.argv) != 3: # not enough (or too much) args
-        logging.getLogger().error('HOOK %s : I was not called with the right number of arguments (two expected, got %d)' % (sys.argv[0], len(sys.argv) - 1))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    mac = sys.argv[1]
-    if not pulse2.utils.isMACAddress(mac):
-        logging.getLogger().error('HOOK %s : First arg (%s) do not seems to be a MAC address' % (sys.argv[0], mac))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-    try:
-        callFunction(imagingAPI.computerCreateImageDirectory(mac))
-    except AttributeError, e:
-        logging.getLogger().error('HOOK %s : %s' % (sys.argv[0], e))
-        exitcode = ERROR_CLIENT
-        return endBack()
-
-
-def myTreatment(result):
-    """
-        Design your own treatment here
-
-        don't forget to set exitcode and finally call endBack()
-    """
-    global exitcode
-    if pulse2.utils.isUUID(result):
-        # result shall be my UUID
-
-        filename = sys.argv[2]
-
-        if not os.path.isfile(filename):
-            logging.getLogger().error('HOOK %s : Second arg (%s) do not seems to be an existing file name' % (sys.argv[0], filename))
-            exitcode = ERROR_CLIENT
-            return endBack()
-
-        try :
-            filestream = open(filename, 'w')
-            filestream.write(result)
-            filestream.close()
-        except Exception, e:
-            logging.getLogger().error('HOOK %s : Can\'t write %s : %s, giving up' % (sys.argv[0], filename, e))
-            exitcode = ERROR_CLIENT
-            return endBack()
-
-        exitcode= ERROR_OK
-        logging.getLogger().info('HOOK %s : SUCCESS !' % sys.argv[0])
-    else:
-        exitcode = ERROR_SERVER
-        logging.getLogger().error('HOOK %s : Error server side !' % sys.argv[0])
-
-    # nothing else to do
-    return endBack()
-
-########################################################################
-#         NOTHING SHOULD BE ALTERED BELOW THIS LINE                    #
-########################################################################
-
-
-def endBack(when = None):
-    """
-        take the reactor down
-    """
-    if when == "timeout" :
-        logging.getLogger().error('HOOK %s : Killed by a timeout' % sys.argv[0])
-    twisted.internet.reactor.callLater(0, twisted.internet.reactor.stop)
-
-
-def callBack(result):
-    """
-        XMLRPC result treatment
-
-        check if it was a success by analysing result
-        if it is a success, call myCall(result)
-        if not, exitcode is set to ERROR_SERVER then call endBack()
-    """
-
-    global exitcode
-    # if result is a list and the first arg a string and its value,
-    # 'PULSE2_ERR', then something went wrong
-    if type(result) == list and len(result) > 0 and type(result[0]) == str and result[0] == 'PULSE2_ERR':
-        logging.getLogger().error("HOOK %s : Error code = %d (see previous line)" % (sys.argv[0], result[1]))
-        exitcode = ERROR_SERVER
-        return endBack()
-    else:
-        logging.getLogger().debug("%s : No error" % (sys.argv[0]))
-        exitcode = ERROR_CLIENT
-        myTreatment(result)
-
-
-def errorBack(reason):
-    """
-        XMLRPC error treatment
-
-        just set exitcode to ERROR_CLIENT then call endBack()
-    """
-    global exitcode
-    exitcode = ERROR_CLIENT
-    return endBack()
-
-
-def callFunction(deffered):
-    """
-        XMLRPC request handling
-
-        attach callBack() and errorBack() to the deferred
-    """
-    deffered.addCallbacks( # deferred handling
-        callBack,
-        errorBack)
-
-# Parse the command line
-config = pulse2.imaging_server.config.ImagingConfig() #: ConfigParser object
-config.setup(CONFIG_FILE)
-logging.config.fileConfig(CONFIG_FILE)
-
-# Instanciate the API
-imagingAPI = pulse2.apis.clients.imaging.ImagingApi({
-    "server" : config.pserver_host,
-    "port" : config.pserver_port,
-    "mountpoint" : config.pserver_mount_point,
-    "enablessl" : config.pserver_enablessl,
-    "username" : config.pserver_username,
-    "password" : config.pserver_password,
-    "verifypeer" : config.pserver_verifypeer,
-    "localcert" : config.pserver_localcert,
-    "cacert" : config.pserver_cacert,
-}) #: Object which will be used to speak with our pserver
-
-# anti-blocking stuff
-# I have 30 seconds to get my result or be killed
-twisted.internet.reactor.callLater(10, endBack, "timeout")
-
-# fire the reactor
-twisted.internet.reactor.callWhenRunning(myCall)
-twisted.internet.reactor.run()
-sys.exit(exitcode)
diff --git a/pulse2/services/src/Makefile.am b/pulse2/services/src/Makefile.am
deleted file mode 100644
index 97f53a1..0000000
--- a/pulse2/services/src/Makefile.am
+++ /dev/null
@@ -1,29 +0,0 @@
-# (c) 2011 Mandriva, http://www.mandriva.com
-#
-# $Id$
-#
-# This file is part of Mandriva Pulse2 project.
-#
-# This software is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This software is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this software.  If not, see <http://www.gnu.org/licenses/>.
-#
-# Author(s):
-#   Jean Parpaillon <jparpaillon@mandriva.com>
-#
-sbin_PROGRAMS = pulse2-imaging-server
-
-pulse2_imaging_server_SOURCES = dictionary.c dictionary.h \
-	iniparser.c iniparser.h site.h \
-	pulse2-imaging-server.c pulse2-imaging-server.h \
-	strlib.c strlib.h
-pulse2_imaging_server_CFLAGS = -O2 -Wall -Wextra -std=gnu99 -DSYSCONFDIR=\"$(sysconfdir)\"
diff --git a/pulse2/services/src/dictionary.c b/pulse2/services/src/dictionary.c
deleted file mode 100644
index 565cee6..0000000
--- a/pulse2/services/src/dictionary.c
+++ /dev/null
@@ -1,508 +0,0 @@
-
-/*-------------------------------------------------------------------------*/
-/**
-   @file	dictionary.c
-   @author	N. Devillard
-   @date	Aug 2000
-   @version	$Revision$
-   @brief	Implements a dictionary for string variables.
-
-   This module implements a simple dictionary object, i.e. a list
-   of string/string associations. This object is useful to store e.g.
-   informations retrieved from a configuration file (ini files).
-*/
-/*--------------------------------------------------------------------------*/
-
-/*
-	$Id$
-	$Author$
-	$Date$
-	$Revision$
-*/
-
-/*---------------------------------------------------------------------------
-   								Includes
- ---------------------------------------------------------------------------*/
-
-#include "dictionary.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-
-
-/** Maximum value size for integers and doubles. */
-#define MAXVALSZ	1024
-
-/** Minimal allocated number of entries in a dictionary */
-#define DICTMINSZ	128
-
-/** Invalid key token */
-#define DICT_INVALID_KEY    ((char*)-1)
-
-
-/*---------------------------------------------------------------------------
-  							Private functions
- ---------------------------------------------------------------------------*/
-
-/* Doubles the allocated size associated to a pointer */
-/* 'size' is the current allocated size. */
-static void * mem_double(void * ptr, int size)
-{
-    void    *   newptr ;
- 
-    newptr = calloc(2*size, 1);
-    memcpy(newptr, ptr, size);
-    free(ptr);
-    return newptr ;
-}
-
-
-/*---------------------------------------------------------------------------
-  							Function codes
- ---------------------------------------------------------------------------*/
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief	Compute the hash key for a string.
-  @param	key		Character string to use for key.
-  @return	1 unsigned int on at least 32 bits.
-
-  This hash function has been taken from an Article in Dr Dobbs Journal.
-  This is normally a collision-free function, distributing keys evenly.
-  The key is stored anyway in the struct so that collision can be avoided
-  by comparing the key itself in last resort.
- */
-/*--------------------------------------------------------------------------*/
-
-unsigned dictionary_hash(char * key)
-{
-	int			len ;
-	unsigned	hash ;
-	int			i ;
-
-	len = strlen(key);
-	for (hash=0, i=0 ; i<len ; i++) {
-		hash += (unsigned)key[i] ;
-		hash += (hash<<10);
-		hash ^= (hash>>6) ;
-	}
-	hash += (hash <<3);
-	hash ^= (hash >>11);
-	hash += (hash <<15);
-	return hash ;
-}
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief	Create a new dictionary object.
-  @param	size	Optional initial size of the dictionary.
-  @return	1 newly allocated dictionary objet.
-
-  This function allocates a new dictionary object of given size and returns
-  it. If you do not know in advance (roughly) the number of entries in the
-  dictionary, give size=0.
- */
-/*--------------------------------------------------------------------------*/
-
-dictionary * dictionary_new(int size)
-{
-	dictionary	*	d ;
-
-	/* If no size was specified, allocate space for DICTMINSZ */
-	if (size<DICTMINSZ) size=DICTMINSZ ;
-
-	d = calloc(1, sizeof(dictionary));
-	d->size = size ;
-	d->val  = calloc(size, sizeof(char*));
-	d->key  = calloc(size, sizeof(char*));
-	d->hash = calloc(size, sizeof(unsigned));
-	return d ;
-}
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief	Delete a dictionary object
-  @param	d	dictionary object to deallocate.
-  @return	void
-
-  Deallocate a dictionary object and all memory associated to it.
- */
-/*--------------------------------------------------------------------------*/
-
-void dictionary_del(dictionary * d)
-{
-	int		i ;
-
-	if (d==NULL) return ;
-	for (i=0 ; i<d->size ; i++) {
-		if (d->key[i]!=NULL)
-			free(d->key[i]);
-		if (d->val[i]!=NULL)
-			free(d->val[i]);
-	}
-	free(d->val);
-	free(d->key);
-	free(d->hash);
-	free(d);
-	return ;
-}
-
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief	Get a value from a dictionary.
-  @param	d		dictionary object to search.
-  @param	key		Key to look for in the dictionary.
-  @param    def     Default value to return if key not found.
-  @return	1 pointer to internally allocated character string.
-
-  This function locates a key in a dictionary and returns a pointer to its
-  value, or the passed 'def' pointer if no such key can be found in
-  dictionary. The returned character pointer points to data internal to the
-  dictionary object, you should not try to free it or modify it.
- */
-/*--------------------------------------------------------------------------*/
-char * dictionary_get(dictionary * d, char * key, char * def)
-{
-	unsigned	hash ;
-	int			i ;
-
-	hash = dictionary_hash(key);
-	for (i=0 ; i<d->size ; i++) {
-        if (d->key==NULL)
-            continue ;
-        /* Compare hash */
-		if (hash==d->hash[i]) {
-            /* Compare string, to avoid hash collisions */
-            if (!strcmp(key, d->key[i])) {
-				return d->val[i] ;
-			}
-		}
-	}
-	return def ;
-}
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief	Get a value from a dictionary, as a char.
-  @param	d		dictionary object to search.
-  @param	key		Key to look for in the dictionary.
-  @param	def		Default value for the key if not found.
-  @return 	char	
-
-  This function locates a key in a dictionary using dictionary_get,
-  and returns the first char of the found string.
- */
-/*--------------------------------------------------------------------------*/
-char dictionary_getchar(dictionary * d, char * key, char def)
-{
-	char * v ;
-
-	if ((v=dictionary_get(d,key,DICT_INVALID_KEY))==DICT_INVALID_KEY) {
-		return def ;
-	} else {
-		return v[0] ;
-	}
-}
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief	Get a value from a dictionary, as an int.
-  @param	d		dictionary object to search.
-  @param	key		Key to look for in the dictionary.
-  @param	def		Default value for the key if not found.
-  @return	int
-
-  This function locates a key in a dictionary using dictionary_get,
-  and applies atoi on it to return an int. If the value cannot be found
-  in the dictionary, the default is returned.
- */
-/*--------------------------------------------------------------------------*/
-int dictionary_getint(dictionary * d, char * key, int def)
-{
-	char * v ;
-
-	if ((v=dictionary_get(d,key,DICT_INVALID_KEY))==DICT_INVALID_KEY) {
-		return def ;
-	} else {
-		return atoi(v);
-	}
-}
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief		Get a value from a dictionary, as a double.
-  @param	d		dictionary object to search.
-  @param	key		Key to look for in the dictionary.
-  @param	def		Default value for the key if not found.
-  @return	double
-
-  This function locates a key in a dictionary using dictionary_get,
-  and applies atof on it to return a double. If the value cannot be found
-  in the dictionary, the default is returned.
- */
-/*--------------------------------------------------------------------------*/
-double dictionary_getdouble(dictionary * d, char * key, double def)
-{
-	char * v ;
-
-	if ((v=dictionary_get(d,key,DICT_INVALID_KEY))==DICT_INVALID_KEY) {
-		return def ;
-	} else {
-		return atof(v);
-	}
-}
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief	Set a value in a dictionary.
-  @param	d		dictionary object to modify.
-  @param	key		Key to modify or add.
-  @param	val 	Value to add.
-  @return	void
-
-  If the given key is found in the dictionary, the associated value is
-  replaced by the provided one. If the key cannot be found in the
-  dictionary, it is added to it.
-
-  It is Ok to provide a NULL value for val, but NULL values for the dictionary
-  or the key are considered as errors: the function will return immediately
-  in such a case.
-
-  Notice that if you dictionary_set a variable to NULL, a call to
-  dictionary_get will return a NULL value: the variable will be found, and
-  its value (NULL) is returned. In other words, setting the variable
-  content to NULL is equivalent to deleting the variable from the
-  dictionary. It is not possible (in this implementation) to have a key in
-  the dictionary without value.
- */
-/*--------------------------------------------------------------------------*/
-
-void dictionary_set(dictionary * d, char * key, char * val)
-{
-	int			i ;
-	unsigned	hash ;
-
-	if (d==NULL || key==NULL) return ;
-	
-	/* Compute hash for this key */
-	hash = dictionary_hash(key) ;
-	/* Find if value is already in blackboard */
-	if (d->n>0) {
-		for (i=0 ; i<d->size ; i++) {
-            if (d->key[i]==NULL)
-                continue ;
-			if (hash==d->hash[i]) { /* Same hash value */
-				if (!strcmp(key, d->key[i])) {	 /* Same key */
-					/* Found a value: modify and return */
-					if (d->val[i]!=NULL)
-						free(d->val[i]);
-                    d->val[i] = val ? strdup(val) : NULL ;
-                    /* Value has been modified: return */
-					return ;
-				}
-			}
-		}
-	}
-	/* Add a new value */
-	/* See if dictionary needs to grow */
-	if (d->n==d->size) {
-
-		/* Reached maximum size: reallocate blackboard */
-		d->val  = mem_double(d->val,  d->size * sizeof(char*)) ;
-		d->key  = mem_double(d->key,  d->size * sizeof(char*)) ;
-		d->hash = mem_double(d->hash, d->size * sizeof(unsigned)) ;
-
-		/* Double size */
-		d->size *= 2 ;
-	}
-
-    /* Insert key in the first empty slot */
-    for (i=0 ; i<d->size ; i++) {
-        if (d->key[i]==NULL) {
-            /* Add key here */
-            break ;
-        }
-    }
-	/* Copy key */
-	d->key[i]  = strdup(key);
-    d->val[i]  = val ? strdup(val) : NULL ;
-	d->hash[i] = hash;
-	d->n ++ ;
-	return ;
-}
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief	Delete a key in a dictionary
-  @param	d		dictionary object to modify.
-  @param	key		Key to remove.
-  @return   void
-
-  This function deletes a key in a dictionary. Nothing is done if the
-  key cannot be found.
- */
-/*--------------------------------------------------------------------------*/
-void dictionary_unset(dictionary * d, char * key)
-{
-	unsigned	hash ;
-	int			i ;
-
-	hash = dictionary_hash(key);
-	for (i=0 ; i<d->size ; i++) {
-        if (d->key[i]==NULL)
-            continue ;
-        /* Compare hash */
-		if (hash==d->hash[i]) {
-            /* Compare string, to avoid hash collisions */
-            if (!strcmp(key, d->key[i])) {
-                /* Found key */
-                break ;
-			}
-		}
-	}
-    if (i>=d->size)
-        /* Key not found */
-        return ;
-
-    free(d->key[i]);
-    d->key[i] = NULL ;
-    if (d->val[i]!=NULL) {
-        free(d->val[i]);
-        d->val[i] = NULL ;
-    }
-    d->hash[i] = 0 ;
-    d->n -- ;
-    return ;
-}
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief	Set a key in a dictionary, providing an int.
-  @param	d		Dictionary to update.
-  @param	key		Key to modify or add
-  @param	val		Integer value to store (will be stored as a string).
-  @return	void
-
-  This helper function calls dictionary_set() with the provided integer
-  converted to a string using %d.
- */
-/*--------------------------------------------------------------------------*/
-
-
-void dictionary_setint(dictionary * d, char * key, int val)
-{
-	char	sval[MAXVALSZ];
-	sprintf(sval, "%d", val);
-	dictionary_set(d, key, sval);
-}
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief	Set a key in a dictionary, providing a double.
-  @param	d		Dictionary to update.
-  @param	key		Key to modify or add
-  @param	val		Double value to store (will be stored as a string).
-  @return	void
-
-  This helper function calls dictionary_set() with the provided double
-  converted to a string using %g.
- */
-/*--------------------------------------------------------------------------*/
-
-
-void dictionary_setdouble(dictionary * d, char * key, double val)
-{
-	char	sval[MAXVALSZ];
-	sprintf(sval, "%g", val);
-	dictionary_set(d, key, sval);
-}
-
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief	Dump a dictionary to an opened file pointer.
-  @param	d	Dictionary to dump
-  @param	f	Opened file pointer.
-  @return	void
-
-  Dumps a dictionary onto an opened file pointer. Key pairs are printed out
-  as @c [Key]=[Value], one per line. It is Ok to provide stdout or stderr as
-  output file pointers.
- */
-/*--------------------------------------------------------------------------*/
-
-void dictionary_dump(dictionary * d, FILE * out)
-{
-	int		i ;
-
-	if (d==NULL || out==NULL) return ;
-	if (d->n<1) {
-		fprintf(out, "empty dictionary\n");
-		return ;
-	}
-	for (i=0 ; i<d->size ; i++) {
-        if (d->key[i]) {
-            fprintf(out, "%20s\t[%s]\n",
-                    d->key[i],
-                    d->val[i] ? d->val[i] : "UNDEF");
-        }
-	}
-	return ;
-}
-
-
-
-/* Example code */
-#ifdef TESTDIC
-#define NVALS 20000
-int main(int argc, char *argv[])
-{
-	dictionary	*	d ;
-	char	*	val ;
-	int			i ;
-	char		cval[90] ;
-
-	/* allocate blackboard */
-	printf("allocating...\n");
-	d = dictionary_new(0);
-	
-	/* Set values in blackboard */
-	printf("setting %d values...\n", NVALS);
-	for (i=0 ; i<NVALS ; i++) {
-		sprintf(cval, "%04d", i);
-		dictionary_set(d, cval, "salut");
-	}
-	printf("getting %d values...\n", NVALS);
-	for (i=0 ; i<NVALS ; i++) {
-		sprintf(cval, "%04d", i);
-		val = dictionary_get(d, cval, DICT_INVALID_KEY);
-		if (val==DICT_INVALID_KEY) {
-			printf("cannot get value for key [%s]\n", cval);
-		}
-	}
-    printf("unsetting %d values...\n", NVALS);
-	for (i=0 ; i<NVALS ; i++) {
-		sprintf(cval, "%04d", i);
-		dictionary_unset(d, cval);
-	}
-    if (d->n != 0) {
-        printf("error deleting values\n");
-    }
-
-	printf("deallocating...\n");
-	dictionary_del(d);
-	return 0 ;
-}
-#endif
-/* vim: set ts=4 et sw=4 tw=75 */
diff --git a/pulse2/services/src/dictionary.h b/pulse2/services/src/dictionary.h
deleted file mode 100644
index 7ba350a..0000000
--- a/pulse2/services/src/dictionary.h
+++ /dev/null
@@ -1,244 +0,0 @@
-
-/*-------------------------------------------------------------------------*/
-/**
-   @file    dictionary.h
-   @author  N. Devillard
-   @date    Aug 2000
-   @version $Revision$
-   @brief   Implements a dictionary for string variables.
-
-   This module implements a simple dictionary object, i.e. a list
-   of string/string associations. This object is useful to store e.g.
-   informations retrieved from a configuration file (ini files).
-*/
-/*--------------------------------------------------------------------------*/
-
-/*
-	$Id$
-	$Author$
-	$Date$
-	$Revision$
-*/
-
-#ifndef _DICTIONARY_H_
-#define _DICTIONARY_H_
-
-/*---------------------------------------------------------------------------
-   								Includes
- ---------------------------------------------------------------------------*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-
-/*---------------------------------------------------------------------------
-   								New types
- ---------------------------------------------------------------------------*/
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief	Dictionary object
-
-  This object contains a list of string/string associations. Each
-  association is identified by a unique string key. Looking up values
-  in the dictionary is speeded up by the use of a (hopefully collision-free)
-  hash function.
- */
-/*-------------------------------------------------------------------------*/
-typedef struct _dictionary_ {
-	int				n ;		/** Number of entries in dictionary */
-	int				size ;	/** Storage size */
-	char 		**	val ;	/** List of string values */
-	char 		**  key ;	/** List of string keys */
-	unsigned	 *	hash ;	/** List of hash values for keys */
-} dictionary ;
-
-
-/*---------------------------------------------------------------------------
-  							Function prototypes
- ---------------------------------------------------------------------------*/
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Compute the hash key for a string.
-  @param    key     Character string to use for key.
-  @return   1 unsigned int on at least 32 bits.
-
-  This hash function has been taken from an Article in Dr Dobbs Journal.
-  This is normally a collision-free function, distributing keys evenly.
-  The key is stored anyway in the struct so that collision can be avoided
-  by comparing the key itself in last resort.
- */
-/*--------------------------------------------------------------------------*/
-unsigned dictionary_hash(char * key);
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Create a new dictionary object.
-  @param    size    Optional initial size of the dictionary.
-  @return   1 newly allocated dictionary objet.
-
-  This function allocates a new dictionary object of given size and returns
-  it. If you do not know in advance (roughly) the number of entries in the
-  dictionary, give size=0.
- */
-/*--------------------------------------------------------------------------*/
-dictionary * dictionary_new(int size);
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Delete a dictionary object
-  @param    d   dictionary object to deallocate.
-  @return   void
-
-  Deallocate a dictionary object and all memory associated to it.
- */
-/*--------------------------------------------------------------------------*/
-void dictionary_del(dictionary * vd);
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Get a value from a dictionary.
-  @param    d       dictionary object to search.
-  @param    key     Key to look for in the dictionary.
-  @param    def     Default value to return if key not found.
-  @return   1 pointer to internally allocated character string.
-
-  This function locates a key in a dictionary and returns a pointer to its
-  value, or the passed 'def' pointer if no such key can be found in
-  dictionary. The returned character pointer points to data internal to the
-  dictionary object, you should not try to free it or modify it.
- */
-/*--------------------------------------------------------------------------*/
-char * dictionary_get(dictionary * d, char * key, char * def);
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Get a value from a dictionary, as a char.
-  @param    d       dictionary object to search.
-  @param    key     Key to look for in the dictionary.
-  @param    def     Default value for the key if not found.
-  @return   char    
-
-  This function locates a key in a dictionary using dictionary_get,
-  and returns the first char of the found string.
- */
-/*--------------------------------------------------------------------------*/
-char dictionary_getchar(dictionary * d, char * key, char def) ;
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Get a value from a dictionary, as an int.
-  @param    d       dictionary object to search.
-  @param    key     Key to look for in the dictionary.
-  @param    def     Default value for the key if not found.
-  @return   int
-
-  This function locates a key in a dictionary using dictionary_get,
-  and applies atoi on it to return an int. If the value cannot be found
-  in the dictionary, the default is returned.
- */
-/*--------------------------------------------------------------------------*/
-int dictionary_getint(dictionary * d, char * key, int def);
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief        Get a value from a dictionary, as a double.
-  @param    d       dictionary object to search.
-  @param    key     Key to look for in the dictionary.
-  @param    def     Default value for the key if not found.
-  @return   double
-
-  This function locates a key in a dictionary using dictionary_get,
-  and applies atof on it to return a double. If the value cannot be found
-  in the dictionary, the default is returned.
- */
-/*--------------------------------------------------------------------------*/
-double dictionary_getdouble(dictionary * d, char * key, double def);
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Set a value in a dictionary.
-  @param    d       dictionary object to modify.
-  @param    key     Key to modify or add.
-  @param    val     Value to add.
-  @return   void
-
-  If the given key is found in the dictionary, the associated value is
-  replaced by the provided one. If the key cannot be found in the
-  dictionary, it is added to it.
-
-  It is Ok to provide a NULL value for val, but NULL values for the dictionary
-  or the key are considered as errors: the function will return immediately
-  in such a case.
-
-  Notice that if you dictionary_set a variable to NULL, a call to
-  dictionary_get will return a NULL value: the variable will be found, and
-  its value (NULL) is returned. In other words, setting the variable
-  content to NULL is equivalent to deleting the variable from the
-  dictionary. It is not possible (in this implementation) to have a key in
-  the dictionary without value.
- */
-/*--------------------------------------------------------------------------*/
-void dictionary_set(dictionary * vd, char * key, char * val);
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Delete a key in a dictionary
-  @param    d       dictionary object to modify.
-  @param    key     Key to remove.
-  @return   void
-
-  This function deletes a key in a dictionary. Nothing is done if the
-  key cannot be found.
- */
-/*--------------------------------------------------------------------------*/
-void dictionary_unset(dictionary * d, char * key);
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Set a key in a dictionary, providing an int.
-  @param    d       Dictionary to update.
-  @param    key     Key to modify or add
-  @param    val     Integer value to store (will be stored as a string).
-  @return   void
-
-  This helper function calls dictionary_set() with the provided integer
-  converted to a string using %d.
- */
-/*--------------------------------------------------------------------------*/
-void dictionary_setint(dictionary * d, char * key, int val);
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Set a key in a dictionary, providing a double.
-  @param    d       Dictionary to update.
-  @param    key     Key to modify or add
-  @param    val     Double value to store (will be stored as a string).
-  @return   void
-
-  This helper function calls dictionary_set() with the provided double
-  converted to a string using %g.
- */
-/*--------------------------------------------------------------------------*/
-void dictionary_setdouble(dictionary * d, char * key, double val);
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Dump a dictionary to an opened file pointer.
-  @param    d   Dictionary to dump
-  @param    f   Opened file pointer.
-  @return   void
-
-  Dumps a dictionary onto an opened file pointer. Key pairs are printed out
-  as @c [Key]=[Value], one per line. It is Ok to provide stdout or stderr as
-  output file pointers.
- */
-/*--------------------------------------------------------------------------*/
-void dictionary_dump(dictionary * d, FILE * out);
-
-#endif
diff --git a/pulse2/services/src/iniparser.c b/pulse2/services/src/iniparser.c
deleted file mode 100644
index cd3b466..0000000
--- a/pulse2/services/src/iniparser.c
+++ /dev/null
@@ -1,517 +0,0 @@
-
-/*-------------------------------------------------------------------------*/
-/**
-   @file    iniparser.c
-   @author  N. Devillard
-   @date    Mar 2000
-   @version $Revision$
-   @brief   Parser for ini files.
-*/
-/*--------------------------------------------------------------------------*/
-
-/*
-    $Id$
-    $Author$
-    $Date$
-    $Revision$
-*/
-
-/*---------------------------------------------------------------------------
-                                Includes
- ---------------------------------------------------------------------------*/
-
-#include "iniparser.h"
-#include "strlib.h"
-
-#define ASCIILINESZ         1024
-#define INI_INVALID_KEY     ((char*)-1)
-
-/*---------------------------------------------------------------------------
-                        Private to this module
- ---------------------------------------------------------------------------*/
-
-/* Private: add an entry to the dictionary */
-static void iniparser_add_entry(
-    dictionary * d,
-    char * sec,
-    char * key,
-    char * val)
-{
-    char longkey[2*ASCIILINESZ+1];
-
-    /* Make a key as section:keyword */
-    if (key!=NULL) {
-        sprintf(longkey, "%s:%s", sec, key);
-    } else {
-        strcpy(longkey, sec);
-    }
-
-    /* Add (key,val) to dictionary */
-    dictionary_set(d, longkey, val);
-    return ;
-}
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Get number of sections in a dictionary
-  @param    d   Dictionary to examine
-  @return   int Number of sections found in dictionary
-
-  This function returns the number of sections found in a dictionary.
-  The test to recognize sections is done on the string stored in the
-  dictionary: a section name is given as "section" whereas a key is
-  stored as "section:key", thus the test looks for entries that do not
-  contain a colon.
-
-  This clearly fails in the case a section name contains a colon, but
-  this should simply be avoided.
-
-  This function returns -1 in case of error.
- */
-/*--------------------------------------------------------------------------*/
-
-int iniparser_getnsec(dictionary * d)
-{
-    int i ;
-    int nsec ;
-
-    if (d==NULL) return -1 ;
-    nsec=0 ;
-    for (i=0 ; i<d->size ; i++) {
-        if (d->key[i]==NULL)
-            continue ;
-        if (strchr(d->key[i], ':')==NULL) {
-            nsec ++ ;
-        }
-    }
-    return nsec ;
-}
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Get name for section n in a dictionary.
-  @param    d   Dictionary to examine
-  @param    n   Section number (from 0 to nsec-1).
-  @return   Pointer to char string
-
-  This function locates the n-th section in a dictionary and returns
-  its name as a pointer to a string statically allocated inside the
-  dictionary. Do not free or modify the returned string!
-
-  This function returns NULL in case of error.
- */
-/*--------------------------------------------------------------------------*/
-
-char * iniparser_getsecname(dictionary * d, int n)
-{
-    int i ;
-    int foundsec ;
-
-    if (d==NULL || n<0) return NULL ;
-    foundsec=0 ;
-    for (i=0 ; i<d->size ; i++) {
-        if (d->key[i]==NULL)
-            continue ;
-        if (strchr(d->key[i], ':')==NULL) {
-            foundsec++ ;
-            if (foundsec>n)
-                break ;
-        }
-    }
-    if (foundsec<=n) {
-        return NULL ;
-    }
-    return d->key[i] ;
-}
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Dump a dictionary to an opened file pointer.
-  @param    d   Dictionary to dump.
-  @param    f   Opened file pointer to dump to.
-  @return   void
-
-  This function prints out the contents of a dictionary, one element by
-  line, onto the provided file pointer. It is OK to specify @c stderr
-  or @c stdout as output files. This function is meant for debugging
-  purposes mostly.
- */
-/*--------------------------------------------------------------------------*/
-void iniparser_dump(dictionary * d, FILE * f)
-{
-    int     i ;
-
-    if (d==NULL || f==NULL) return ;
-    for (i=0 ; i<d->size ; i++) {
-        if (d->key[i]==NULL)
-            continue ;
-        if (d->val[i]!=NULL) {
-            fprintf(f, "[%s]=[%s]\n", d->key[i], d->val[i]);
-        } else {
-            fprintf(f, "[%s]=UNDEF\n", d->key[i]);
-        }
-    }
-    return ;
-}
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Save a dictionary to a loadable ini file
-  @param    d   Dictionary to dump
-  @param    f   Opened file pointer to dump to
-  @return   void
-
-  This function dumps a given dictionary into a loadable ini file.
-  It is Ok to specify @c stderr or @c stdout as output files.
- */
-/*--------------------------------------------------------------------------*/
-
-void iniparser_dump_ini(dictionary * d, FILE * f)
-{
-    int     i, j ;
-    char    keym[ASCIILINESZ+1];
-    int     nsec ;
-    char *  secname ;
-    int     seclen ;
-
-    if (d==NULL || f==NULL) return ;
-
-    nsec = iniparser_getnsec(d);
-    if (nsec<1) {
-        /* No section in file: dump all keys as they are */
-        for (i=0 ; i<d->size ; i++) {
-            if (d->key[i]==NULL)
-                continue ;
-            fprintf(f, "%s = %s\n", d->key[i], d->val[i]);
-        }
-        return ;
-    }
-    for (i=0 ; i<nsec ; i++) {
-        secname = iniparser_getsecname(d, i) ;
-        seclen  = (int)strlen(secname);
-        fprintf(f, "\n[%s]\n", secname);
-        sprintf(keym, "%s:", secname);
-        for (j=0 ; j<d->size ; j++) {
-            if (d->key[j]==NULL)
-                continue ;
-            if (!strncmp(d->key[j], keym, seclen+1)) {
-                fprintf(f,
-                        "%-30s = %s\n",
-                        d->key[j]+seclen+1,
-                        d->val[j] ? d->val[j] : "");
-            }
-        }
-    }
-    fprintf(f, "\n");
-    return ;
-}
-
-
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief	Get the string associated to a key, return NULL if not found
-  @param    d   Dictionary to search
-  @param    key Key string to look for
-  @return   pointer to statically allocated character string, or NULL.
-
-  This function queries a dictionary for a key. A key as read from an
-  ini file is given as "section:key". If the key cannot be found,
-  NULL is returned.
-  The returned char pointer is pointing to a string allocated in
-  the dictionary, do not free or modify it.
-
-  This function is only provided for backwards compatibility with 
-  previous versions of iniparser. It is recommended to use
-  iniparser_getstring() instead.
- */
-/*--------------------------------------------------------------------------*/
-char * iniparser_getstr(dictionary * d, char * key)
-{
-    return iniparser_getstring(d, key, NULL);
-}
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Get the string associated to a key
-  @param    d       Dictionary to search
-  @param    key     Key string to look for
-  @param    def     Default value to return if key not found.
-  @return   pointer to statically allocated character string
-
-  This function queries a dictionary for a key. A key as read from an
-  ini file is given as "section:key". If the key cannot be found,
-  the pointer passed as 'def' is returned.
-  The returned char pointer is pointing to a string allocated in
-  the dictionary, do not free or modify it.
- */
-/*--------------------------------------------------------------------------*/
-char * iniparser_getstring(dictionary * d, char * key, char * def)
-{
-    char * lc_key ;
-    char * sval ;
-
-    if (d==NULL || key==NULL)
-        return def ;
-
-    lc_key = strdup(strlwc(key));
-    sval = dictionary_get(d, lc_key, def);
-    free(lc_key);
-    return sval ;
-}
-
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Get the string associated to a key, convert to an int
-  @param    d Dictionary to search
-  @param    key Key string to look for
-  @param    notfound Value to return in case of error
-  @return   integer
-
-  This function queries a dictionary for a key. A key as read from an
-  ini file is given as "section:key". If the key cannot be found,
-  the notfound value is returned.
- */
-/*--------------------------------------------------------------------------*/
-int iniparser_getint(dictionary * d, char * key, int notfound)
-{
-    char    *   str ;
-
-    str = iniparser_getstring(d, key, INI_INVALID_KEY);
-    if (str==INI_INVALID_KEY) return notfound ;
-    return atoi(str);
-}
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Get the string associated to a key, convert to a double
-  @param    d Dictionary to search
-  @param    key Key string to look for
-  @param    notfound Value to return in case of error
-  @return   double
-
-  This function queries a dictionary for a key. A key as read from an
-  ini file is given as "section:key". If the key cannot be found,
-  the notfound value is returned.
- */
-/*--------------------------------------------------------------------------*/
-double iniparser_getdouble(dictionary * d, char * key, double notfound)
-{
-    char    *   str ;
-
-    str = iniparser_getstring(d, key, INI_INVALID_KEY);
-    if (str==INI_INVALID_KEY) return notfound ;
-    return atof(str);
-}
-
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Get the string associated to a key, convert to a boolean
-  @param    d Dictionary to search
-  @param    key Key string to look for
-  @param    notfound Value to return in case of error
-  @return   integer
-
-  This function queries a dictionary for a key. A key as read from an
-  ini file is given as "section:key". If the key cannot be found,
-  the notfound value is returned.
-
-  A true boolean is found if one of the following is matched:
-
-  - A string starting with 'y'
-  - A string starting with 'Y'
-  - A string starting with 't'
-  - A string starting with 'T'
-  - A string starting with '1'
-
-  A false boolean is found if one of the following is matched:
-
-  - A string starting with 'n'
-  - A string starting with 'N'
-  - A string starting with 'f'
-  - A string starting with 'F'
-  - A string starting with '0'
-
-  The notfound value returned if no boolean is identified, does not
-  necessarily have to be 0 or 1.
- */
-/*--------------------------------------------------------------------------*/
-int iniparser_getboolean(dictionary * d, char * key, int notfound)
-{
-    char    *   c ;
-    int         ret ;
-
-    c = iniparser_getstring(d, key, INI_INVALID_KEY);
-    if (c==INI_INVALID_KEY) return notfound ;
-    if (c[0]=='y' || c[0]=='Y' || c[0]=='1' || c[0]=='t' || c[0]=='T') {
-        ret = 1 ;
-    } else if (c[0]=='n' || c[0]=='N' || c[0]=='0' || c[0]=='f' || c[0]=='F') {
-        ret = 0 ;
-    } else {
-        ret = notfound ;
-    }
-    return ret;
-}
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Finds out if a given entry exists in a dictionary
-  @param    ini     Dictionary to search
-  @param    entry   Name of the entry to look for
-  @return   integer 1 if entry exists, 0 otherwise
-
-  Finds out if a given entry exists in the dictionary. Since sections
-  are stored as keys with NULL associated values, this is the only way
-  of querying for the presence of sections in a dictionary.
- */
-/*--------------------------------------------------------------------------*/
-
-int iniparser_find_entry(
-    dictionary  *   ini,
-    char        *   entry
-)
-{
-    int found=0 ;
-    if (iniparser_getstring(ini, entry, INI_INVALID_KEY)!=INI_INVALID_KEY) {
-        found = 1 ;
-    }
-    return found ;
-}
-
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Set an entry in a dictionary.
-  @param    ini     Dictionary to modify.
-  @param    entry   Entry to modify (entry name)
-  @param    val     New value to associate to the entry.
-  @return   int 0 if Ok, -1 otherwise.
-
-  If the given entry can be found in the dictionary, it is modified to
-  contain the provided value. If it cannot be found, -1 is returned.
-  It is Ok to set val to NULL.
- */
-/*--------------------------------------------------------------------------*/
-
-int iniparser_setstr(dictionary * ini, char * entry, char * val)
-{
-    dictionary_set(ini, strlwc(entry), val);
-    return 0 ;
-}
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Delete an entry in a dictionary
-  @param    ini     Dictionary to modify
-  @param    entry   Entry to delete (entry name)
-  @return   void
-
-  If the given entry can be found, it is deleted from the dictionary.
- */
-/*--------------------------------------------------------------------------*/
-void iniparser_unset(dictionary * ini, char * entry)
-{
-    dictionary_unset(ini, strlwc(entry));
-}
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Parse an ini file and return an allocated dictionary object
-  @param    ininame Name of the ini file to read.
-  @return   Pointer to newly allocated dictionary
-
-  This is the parser for ini files. This function is called, providing
-  the name of the file to be read. It returns a dictionary object that
-  should not be accessed directly, but through accessor functions
-  instead.
-
-  The returned dictionary must be freed using iniparser_freedict().
- */
-/*--------------------------------------------------------------------------*/
-
-dictionary * iniparser_load(char * ininame)
-{
-    dictionary  *   d ;
-    char        lin[ASCIILINESZ+1];
-    char        sec[ASCIILINESZ+1];
-    char        key[ASCIILINESZ+1];
-    char        val[ASCIILINESZ+1];
-    char    *   where ;
-    FILE    *   ini ;
-    int         lineno ;
-
-    if ((ini=fopen(ininame, "r"))==NULL) {
-        return NULL ;
-    }
-
-    sec[0]=0;
-
-    /*
-     * Initialize a new dictionary entry
-     */
-    d = dictionary_new(0);
-    lineno = 0 ;
-    while (fgets(lin, ASCIILINESZ, ini)!=NULL) {
-        lineno++ ;
-        where = strskp(lin); /* Skip leading spaces */
-        if (*where==';' || *where=='#' || *where==0)
-            continue ; /* Comment lines */
-        else {
-            if (sscanf(where, "[%[^]]", sec)==1) {
-                /* Valid section name */
-                strcpy(sec, strlwc(sec));
-                iniparser_add_entry(d, sec, NULL, NULL);
-            } else if (sscanf (where, "%[^=] = \"%[^\"]\"", key, val) == 2
-                   ||  sscanf (where, "%[^=] = '%[^\']'",   key, val) == 2
-                   ||  sscanf (where, "%[^=] = %[^;#]",     key, val) == 2) {
-                strcpy(key, strlwc(strcrop(key)));
-                /*
-                 * sscanf cannot handle "" or '' as empty value,
-                 * this is done here
-                 */
-                if (!strcmp(val, "\"\"") || !strcmp(val, "''")) {
-                    val[0] = (char)0;
-                } else {
-                    strcpy(val, strcrop(val));
-                }
-                iniparser_add_entry(d, sec, key, val);
-            }
-        }
-    }
-    fclose(ini);
-    return d ;
-}
-
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Free all memory associated to an ini dictionary
-  @param    d Dictionary to free
-  @return   void
-
-  Free all memory associated to an ini dictionary.
-  It is mandatory to call this function before the dictionary object
-  gets out of the current context.
- */
-/*--------------------------------------------------------------------------*/
-
-void iniparser_freedict(dictionary * d)
-{
-    dictionary_del(d);
-}
-
-/* vim: set ts=4 et sw=4 tw=75 */
diff --git a/pulse2/services/src/iniparser.h b/pulse2/services/src/iniparser.h
deleted file mode 100644
index 5759aa1..0000000
--- a/pulse2/services/src/iniparser.h
+++ /dev/null
@@ -1,276 +0,0 @@
-
-/*-------------------------------------------------------------------------*/
-/**
-   @file    iniparser.h
-   @author  N. Devillard
-   @date    Mar 2000
-   @version $Revision$
-   @brief   Parser for ini files.
-*/
-/*--------------------------------------------------------------------------*/
-
-/*
-	$Id$
-	$Author$
-	$Date$
-	$Revision$
-*/
-
-#ifndef _INIPARSER_H_
-#define _INIPARSER_H_
-
-/*---------------------------------------------------------------------------
-   								Includes
- ---------------------------------------------------------------------------*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-
-#include "dictionary.h"
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Get number of sections in a dictionary
-  @param    d   Dictionary to examine
-  @return   int Number of sections found in dictionary
-
-  This function returns the number of sections found in a dictionary.
-  The test to recognize sections is done on the string stored in the
-  dictionary: a section name is given as "section" whereas a key is
-  stored as "section:key", thus the test looks for entries that do not
-  contain a colon.
-
-  This clearly fails in the case a section name contains a colon, but
-  this should simply be avoided.
-
-  This function returns -1 in case of error.
- */
-/*--------------------------------------------------------------------------*/
-
-int iniparser_getnsec(dictionary * d);
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Get name for section n in a dictionary.
-  @param    d   Dictionary to examine
-  @param    n   Section number (from 0 to nsec-1).
-  @return   Pointer to char string
-
-  This function locates the n-th section in a dictionary and returns
-  its name as a pointer to a string statically allocated inside the
-  dictionary. Do not free or modify the returned string!
-
-  This function returns NULL in case of error.
- */
-/*--------------------------------------------------------------------------*/
-
-char * iniparser_getsecname(dictionary * d, int n);
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Save a dictionary to a loadable ini file
-  @param    d   Dictionary to dump
-  @param    f   Opened file pointer to dump to
-  @return   void
-
-  This function dumps a given dictionary into a loadable ini file.
-  It is Ok to specify @c stderr or @c stdout as output files.
- */
-/*--------------------------------------------------------------------------*/
-
-void iniparser_dump_ini(dictionary * d, FILE * f);
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Dump a dictionary to an opened file pointer.
-  @param    d   Dictionary to dump.
-  @param    f   Opened file pointer to dump to.
-  @return   void
-
-  This function prints out the contents of a dictionary, one element by
-  line, onto the provided file pointer. It is OK to specify @c stderr
-  or @c stdout as output files. This function is meant for debugging
-  purposes mostly.
- */
-/*--------------------------------------------------------------------------*/
-void iniparser_dump(dictionary * d, FILE * f);
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Get the string associated to a key, return NULL if not found
-  @param    d   Dictionary to search
-  @param    key Key string to look for
-  @return   pointer to statically allocated character string, or NULL.
-
-  This function queries a dictionary for a key. A key as read from an
-  ini file is given as "section:key". If the key cannot be found,
-  NULL is returned.
-  The returned char pointer is pointing to a string allocated in
-  the dictionary, do not free or modify it.
-
-  This function is only provided for backwards compatibility with
-  previous versions of iniparser. It is recommended to use
-  iniparser_getstring() instead.
- */
-/*--------------------------------------------------------------------------*/
-char * iniparser_getstr(dictionary * d, char * key);
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Get the string associated to a key
-  @param    d       Dictionary to search
-  @param    key     Key string to look for
-  @param    def     Default value to return if key not found.
-  @return   pointer to statically allocated character string
-
-  This function queries a dictionary for a key. A key as read from an
-  ini file is given as "section:key". If the key cannot be found,
-  the pointer passed as 'def' is returned.
-  The returned char pointer is pointing to a string allocated in
-  the dictionary, do not free or modify it.
- */
-/*--------------------------------------------------------------------------*/
-char * iniparser_getstring(dictionary * d, char * key, char * def);
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Get the string associated to a key, convert to an int
-  @param    d Dictionary to search
-  @param    key Key string to look for
-  @param    notfound Value to return in case of error
-  @return   integer
-
-  This function queries a dictionary for a key. A key as read from an
-  ini file is given as "section:key". If the key cannot be found,
-  the notfound value is returned.
- */
-/*--------------------------------------------------------------------------*/
-int iniparser_getint(dictionary * d, char * key, int notfound);
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Get the string associated to a key, convert to a double
-  @param    d Dictionary to search
-  @param    key Key string to look for
-  @param    notfound Value to return in case of error
-  @return   double
-
-  This function queries a dictionary for a key. A key as read from an
-  ini file is given as "section:key". If the key cannot be found,
-  the notfound value is returned.
- */
-/*--------------------------------------------------------------------------*/
-double iniparser_getdouble(dictionary * d, char * key, double notfound);
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Get the string associated to a key, convert to a boolean
-  @param    d Dictionary to search
-  @param    key Key string to look for
-  @param    notfound Value to return in case of error
-  @return   integer
-
-  This function queries a dictionary for a key. A key as read from an
-  ini file is given as "section:key". If the key cannot be found,
-  the notfound value is returned.
-
-  A true boolean is found if one of the following is matched:
-
-  - A string starting with 'y'
-  - A string starting with 'Y'
-  - A string starting with 't'
-  - A string starting with 'T'
-  - A string starting with '1'
-
-  A false boolean is found if one of the following is matched:
-
-  - A string starting with 'n'
-  - A string starting with 'N'
-  - A string starting with 'f'
-  - A string starting with 'F'
-  - A string starting with '0'
-
-  The notfound value returned if no boolean is identified, does not
-  necessarily have to be 0 or 1.
- */
-/*--------------------------------------------------------------------------*/
-int iniparser_getboolean(dictionary * d, char * key, int notfound);
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Set an entry in a dictionary.
-  @param    ini     Dictionary to modify.
-  @param    entry   Entry to modify (entry name)
-  @param    val     New value to associate to the entry.
-  @return   int 0 if Ok, -1 otherwise.
-
-  If the given entry can be found in the dictionary, it is modified to
-  contain the provided value. If it cannot be found, -1 is returned.
-  It is Ok to set val to NULL.
- */
-/*--------------------------------------------------------------------------*/
-
-int iniparser_setstr(dictionary * ini, char * entry, char * val);
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Delete an entry in a dictionary
-  @param    ini     Dictionary to modify
-  @param    entry   Entry to delete (entry name)
-  @return   void
-
-  If the given entry can be found, it is deleted from the dictionary.
- */
-/*--------------------------------------------------------------------------*/
-void iniparser_unset(dictionary * ini, char * entry);
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Finds out if a given entry exists in a dictionary
-  @param    ini     Dictionary to search
-  @param    entry   Name of the entry to look for
-  @return   integer 1 if entry exists, 0 otherwise
-
-  Finds out if a given entry exists in the dictionary. Since sections
-  are stored as keys with NULL associated values, this is the only way
-  of querying for the presence of sections in a dictionary.
- */
-/*--------------------------------------------------------------------------*/
-int iniparser_find_entry(dictionary * ini, char * entry) ;
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Parse an ini file and return an allocated dictionary object
-  @param    ininame Name of the ini file to read.
-  @return   Pointer to newly allocated dictionary
-
-  This is the parser for ini files. This function is called, providing
-  the name of the file to be read. It returns a dictionary object that
-  should not be accessed directly, but through accessor functions
-  instead.
-
-  The returned dictionary must be freed using iniparser_freedict().
- */
-/*--------------------------------------------------------------------------*/
-dictionary * iniparser_load(char * ininame);
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Free all memory associated to an ini dictionary
-  @param    d Dictionary to free
-  @return   void
-
-  Free all memory associated to an ini dictionary.
-  It is mandatory to call this function before the dictionary object
-  gets out of the current context.
- */
-/*--------------------------------------------------------------------------*/
-void iniparser_freedict(dictionary * d);
-
-#endif
diff --git a/pulse2/services/src/pulse2-imaging-server.c b/pulse2/services/src/pulse2-imaging-server.c
deleted file mode 100644
index 58af5c4..0000000
--- a/pulse2/services/src/pulse2-imaging-server.c
+++ /dev/null
@@ -1,1122 +0,0 @@
-/*
- * (c) 2003-2007 Linbox FAS, http://linbox.com
- * (c) 2008-2010 Mandriva, http://www.mandriva.com
- *
- * $Id$
- *
- * This file is part of Pulse 2, http://pulse2.mandriva.org
- *
- * Pulse 2 is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Pulse 2 is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with Pulse 2; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA 02110-1301, USA.
- */
-
-#include "pulse2-imaging-server.h"
-
-void initlog(void) {
-    openlog("pulse2-imaging-server", 0, LOG_DAEMON | LOG_LOCAL3);
-}
-
-/*
- * logging
- */
-
-int myLogger(char *msg) {
-    time_t rawtime;
-    struct tm * timeinfo;
-    char timebuffer[24];
-    char buffer[1024];
-    FILE *fi;
-
-    bzero(buffer, sizeof(buffer));
-    // gather timestamp
-    time(&rawtime);
-    timeinfo = localtime (&rawtime);
-    strftime(timebuffer, sizeof(timebuffer), "%Y-%m-%d %H:%M:%S,000", timeinfo);
-
-    // prepare logging message
-    snprintf(buffer, sizeof(buffer), "%s %.900s\n", timebuffer, msg);
-
-    fi = fopen(gLogFile, "a");
-    if (!fi)
-        return 0;
-
-    if (fwrite(buffer, sizeof(buffer), 1, fi) < 1) {
-        perror("Error when writing file");
-    }
-
-    fclose(fi);
-
-    return 0;
-}
-
-void hex2char(char *ptr, char *val) {
-    if ((ptr[1] >= 'A') && (ptr[1] <= 'F'))
-        *val = ptr[1] - 'A' + 10;
-    else if ((ptr[1] >= 'a') && (ptr[1] <= 'f'))
-        *val = ptr[1] - 'a' + 10;
-    else if ((ptr[1] >= '0') && (ptr[1] <= '9'))
-        *val = ptr[1] - '0';
-    else {
-        *val = 0;
-        return;
-    }
-
-    if ((ptr[0] >= 'A') && (ptr[0] <= 'F'))
-        *val += (16 * (ptr[0] - 'A' + 10));
-    else if ((ptr[0] >= 'a') && (ptr[0] <= 'f'))
-        *val += (16 * (ptr[0] - 'a' + 10));
-    else if ((ptr[0] >= '0') && (ptr[0] <= '9'))
-        *val += (16 * (ptr[0] - '0'));
-    else {
-        *val = 0;
-        return;
-    }
-}
-
-void diep(char *s) {
-    time_t now;
-    char *ts;
-
-    time(&now);
-    ts = ctime(&now) + 4;
-    ts[20] = '\0';
-
-    if (errno) {
-        perror(s);
-    } else {
-        puts(s);
-    }
-    syslog(LOG_ERR, "%s", s);
-    exit(1);
-}
-
-int analyseresult(int exitcode) {
-/*
- * log stuff based on the exitcdoe value
- */
-    switch (exitcode) {
-    case 0:
-        /* myLogger("Hook succeeded !"); */ /* Prevent logging : useless in case of success */
-        return 0;
-    case 1:
-        myLogger("Hook failed server side !");
-        return 1;
-    case 2:
-        myLogger("Hook failed client side !");
-        return 1;
-    case 3:
-        myLogger("Hook failed !");
-        return 1;
-    default:
-        myLogger("ERROR : something unexpected happend !");
-        return 1;
-    }
-}
-
-/*
- * system() func with logging
- */
-int mysystem(int argc, ...) {
-    char cmd[1024];
-    char tmp[1024];
-    int count = 0;
-    int retval = 0;
-    va_list argv;
-
-    bzero(cmd, sizeof(cmd));
-    bzero(tmp, sizeof(tmp));
-
-    va_start(argv, argc);
-    while (argc--) {
-        if (count)
-            snprintf(tmp, 1024, "%s %s", cmd, va_arg(argv, char *));
-        else
-            snprintf(tmp, 1024, "%s", va_arg(argv, char *));
-        strncpy(cmd, tmp, 1024);
-        count++;
-    }
-    va_end(argv);
-
-    snprintf(tmp, 1023, "Command %.900s", cmd);
-    myLogger(tmp);
-
-    snprintf(tmp, 1023, "%.900s 1>>%s 2>&1", cmd, gLogFile);
-    /* we now take care of the error code : */
-    retval = WEXITSTATUS(system(tmp));
-    return retval;
-}
-/*
- * system() func with logging
- * mysystem1 pour que le mot de passe ne figure pas dans les log
- */
-int mysystem1(int argc, ...) {
-    char cmd[1024];
-    char tmp[1024];
-    char logtmp[1024];
-    int count = 0;
-    int retval = 0;
-    va_list argv;
-
-    bzero(cmd, sizeof(cmd));
-    bzero(tmp, sizeof(tmp));
-
-    va_start(argv, argc);
-    while (argc--) {
-        if (count)
-            snprintf(tmp, 1024, "%s %s", cmd, va_arg(argv, char *));
-        else
-            snprintf(tmp, 1024, "%s", va_arg(argv, char *));
-        strncpy(cmd, tmp, 1024);
-        count++;
-    }
-    va_end(argv);
-    
-    snprintf(logtmp, 1023, "Command authentification");
-    myLogger(logtmp);
-
-    snprintf(tmp, 1023, "%.900s 1>>%s 2>&1", cmd, gLogFile);
-    /* we now take care of the error code : */
-    retval = WEXITSTATUS(system(tmp));
-    return retval;
-}
-void logClientActivity(char *mac, int priority, char *phase,
-                       const char *format_str, ...) {
-    va_list ap;
-    char buf[1024];
-    char prio[8];
-
-    /* write some info */
-    va_start(ap, format_str);
-    vsnprintf(buf, 1023, format_str, ap);
-    va_end(ap);
-
-    snprintf(prio, 2, "%d", priority);
-
-    if (mysystem(5, gPathLogAction, mac, prio, phase, buf) != 0) {
-        /* FIXME : we should send back a NAK */
-    }
-}
-
-/*
- * Get the number of entries
- */
-unsigned int getentries(unsigned char *file) {
-    FILE *fi;
-    unsigned int s = 0;
-    char buf[100];
-
-    fi = fopen((char *)file, "r");
-    if (!fi)
-        return 0;
-    while (fgets(buf, 100, fi))
-        if ((buf[0] != '#') && (buf[0] != ';') && (strlen(buf) > 10))
-            s++;
-    fclose(fi);
-
-    return s;
-}
-
-/*
- * get the name corresponding to a MAC addr
- */
-int getentry(char *file, char *pktmac) {
-    FILE *fi;
-    unsigned int s = 0;
-    char buf[100], mac[20], name[33];
-
-    fi = fopen(file, "r");
-    if (!fi)
-        return 0;
-    while (fgets(buf, 100, fi)) {
-        if ((buf[0] != '#') && (buf[0] != ';') && (strlen(buf) > 10)) {
-            s++;
-            if (sscanf(buf, "%19s%*s%32s", mac, name) == 2) {
-                if (!strncasecmp(mac, pktmac, 17)) {
-                    // return the name in the global buffer
-                    strncpy((char *)gBuff, name, 80);
-                    fclose(fi);
-                    return 1;
-                }
-            }
-        }
-    }
-    fclose(fi);
-
-    return 0;
-}
-
-/*
- *  get mac from the ARP cache
- */
-unsigned char *getmac(struct in_addr addr) {
-    FILE *fi;
-    unsigned char *ptr;
-    char straddr[80];
-    int l;
-
-    strncpy(straddr, inet_ntoa(addr), 15);
-    l = strlen(straddr);
-    straddr[l] = ' ';
-    straddr[l + 1] = '\0';
-
-    myLogger("Warning: MAC not found in packet");
-    fi = fopen("/proc/net/arp", "r");
-    if (!fi) {                  /* can't open file */
-        myLogger("can't open /proc/net/arp");
-        return 0;
-    }
-    while (fgets((char *)gBuff, 80, fi)) {
-        if (strstr((char *)gBuff, straddr)) {
-            ptr = (unsigned char *)strchr((char *)gBuff, ':') - 2;
-            ptr[17] = 0;
-            return ptr;
-        }
-    }
-    return NULL;
-}
-
-/*
- *  get the mac from data embedded in the request
- *
- *  format: "Mc:xx:xx:xx:xx:xx:xx" at the end of the packet
- */
-unsigned char *getmacfrompkt(char *buf, int l) {
-    if (l <= 20)
-        return NULL;
-    /* check for a magic number and for ':' x6 */
-    if (buf[l - 20] == 'M' && buf[l - 19] == 'c' && buf[l - 18] == ':'
-        && buf[l - 15] == ':' && buf[l - 12] == ':' && buf[l - 9] == ':'
-        && buf[l - 6] == ':' && buf[l - 3] == ':') {
-        /* let's copy the mac address */
-        strncpy((char *)gBuff, buf + l - 17, 17);
-        gBuff[17] = 0;
-        return gBuff;
-    }
-    return NULL;
-}
-
-/*
- * Process an incoming packet
- */
-int process_packet(unsigned char *buf, char *mac, char *smac,
-                   struct sockaddr_in *si_other, int s) {
-    int fo;
-    static unsigned int lastfile = 0, lasttime = 0;
-
-
-    char *buff = malloc(256);
-
-    snprintf(buff, 255,
-             "DEBUG Packet from %s:%d, MAC Address:%s, Command: %02x",
-             inet_ntoa(si_other->sin_addr),
-             ntohs(si_other->sin_port),
-             mac,
-             buf[0]);
-    myLogger(buff);
-    free(buff);
-
-    /* Hardware Info... */
-    if (buf[0] == 0xAA) {
-        char buffer[100 * 1024];
-        char filename[256];
-        int buffer_len = 0;
-
-        logClientActivity(mac,
-                          LOG_DEBUG,
-                          PULSE_LOG_STATE_MENU,
-                          "'boot menu shown'");
-        if (analyseresult(mysystem(2, gPathBootClient, mac))) {
-            /* Fixme : We Should also send back a NAK */
-            return 0;
-        }
-
-        logClientActivity(mac,
-                          LOG_DEBUG,
-                          PULSE_LOG_STATE_INVENTORY,
-                          "'hardware inventory received'");
-        /* write inventory to a temporary file. Must fit in one packet ! */
-        snprintf(filename, 255, "/tmp/inventory.pulse2.%s.XXXXXX", smac);
-
-        if (!(fo = mkstemp(filename))) {        // can't create .inf file
-            char *msg = malloc(256);
-            snprintf(msg, 256, "can't create %s", filename);
-            myLogger(msg);
-            free(msg);
-            logClientActivity(mac,
-                              LOG_ERR,
-                              PULSE_LOG_STATE_INVENTORY,
-                              "'hardware inventory not stored'");
-            return 0;
-        }
-        buffer_len = snprintf(buffer, 100 * 1024,
-                              "IP Address:%s:%d\nMAC Address:%s\n%s",
-                              inet_ntoa(si_other->sin_addr),
-                              ntohs(si_other->sin_port), mac, buf + 1);
-
-        if (write(fo, buffer, buffer_len) < 0 ) {
-            perror("Error when writing file");
-        }
-        close(fo);
-
-        if (analyseresult(mysystem(3, gPathProcessInventory, mac, filename))) {
-            // FIXME : we should also send back a NAK
-            logClientActivity(mac,
-                              LOG_WARNING,
-                              PULSE_LOG_STATE_INVENTORY,
-                              "'hardware inventory not updated");
-        } else {
-            logClientActivity(mac,
-                              LOG_INFO,
-                              PULSE_LOG_STATE_INVENTORY,
-                              "'hardware inventory updated'");
-        }
-        unlink(filename);
-        return 0;
-    }
- // identification menu general
-    if (buf[0] == 0xAF)
-    {
-      logClientActivity(mac,
-                              LOG_INFO,
-                              PULSE_LOG_STATE_INDENTITY,
-                              "'identification request Menu'");
-        char re[]="ko";
-        char *ptr, pass[256], buff[256];
-        bzero(pass, sizeof(pass));
-        bzero(buff, sizeof(buff));
-        ptr = strrchr((char *)buf + 1, ':');
-        strncpy(pass, ptr + 1, sizeof(pass));
-        snprintf(buff, 255, "password from %s:%d (%s)",
-                 inet_ntoa(si_other->sin_addr),
-                 ntohs(si_other->sin_port), mac);
-        myLogger(buff);
-    //verify password
-    // mysystem1 pour que le mot de passe ne figure pas dans les log
-	if (mysystem1(3,gClient_auth,pass,mac)==1) {
-            /* Fixme : We Should also send back a NAK */
-            strcpy(re,"ok");
-        }else
-	{
-	  strcpy(re,"ko");
-	}
-        sendto(s,
-                   re,
-                   strlen(re) + 1,
-                   MSG_NOSIGNAL,
-                   (struct sockaddr *)si_other,
-                   sizeof(*si_other));
-        return 0;
-    }
-    // identification
-    if (buf[0] == 0xAD) {
-        char *ptr, pass[256], hostname[256], buff[256];
-        char *answ = malloc(40);
-
-        bzero(pass, sizeof(pass));
-        bzero(hostname, sizeof(hostname));
-        bzero(buff, sizeof(buff));
-
-        logClientActivity(mac,
-                          LOG_DEBUG,
-                          PULSE_LOG_STATE_MENU,
-                          "'identification request'");
-
-        bzero(answ, 40);
-
-        ptr = strrchr((char *)buf + 3, ':');
-        *ptr = 0;
-        strncpy(pass, ptr + 1, sizeof(pass));
-        strncpy(hostname, (char *)buf + 3, sizeof(hostname));
-        snprintf(buff, 255, "Identification from %s:%d (%s) as %s",
-                 inet_ntoa(si_other->sin_addr),
-                 ntohs(si_other->sin_port), mac, hostname);
-        myLogger(buff);
-        if (analyseresult(mysystem(5, 
-				   gPathCreateClient, 
-				   mac, 
-				   hostname, 
-				   inet_ntoa(si_other->sin_addr),
-				   pass))) {
-            logClientActivity(mac,
-                              LOG_WARNING,
-                              PULSE_LOG_STATE_MENU,
-                              "'identification failure'"); // stupid : I'm not in database !
-            strncpy(answ, "KO", 40);
-        } else {
-            logClientActivity(mac,
-                              LOG_DEBUG,
-                              PULSE_LOG_STATE_MENU,
-                              "'identification success'");
-            strncpy(answ, "OK", 40);
-        }
-
-        // FIXME : in time, we should also send back an ACK/ NACK by decommenting the following line
-        // sendto(s, answ, strlen(answ) , MSG_NOSIGNAL, (struct sockaddr *)si_other, sizeof(*si_other));
-
-        free(answ);
-        return 0;
-    }
-
-    // before a save
-    if (buf[0] == 0xEC) {
-        // create a temporary file to get our UUID
-        char filename[256];
-        snprintf(filename, 255, "/tmp/uuid.pulse2.%s.XXXXXX", smac);
-
-        logClientActivity(mac,
-                          LOG_DEBUG,
-                          PULSE_LOG_STATE_BACKUP,
-                          "'image UUID request'");
-
-        if (!(fo = mkstemp(filename))) {        // can't create .inf file
-            char *msg = malloc(256);
-            snprintf(msg, 256, "can't create %s", filename);
-            myLogger(msg);
-            free(msg);
-            logClientActivity(mac,
-                              LOG_ERR,
-                              PULSE_LOG_STATE_BACKUP,
-                              "'failed to summon an image UUID'");
-            return 0;
-        }
-        close(fo);
-
-        if (mysystem(3, gPathStartImage, mac, filename) == 0) {
-            /*
-             * thanks to system(), we do not have any chance to get our
-             * so we uses a temporary file to recover it.
-             * yes, that's quiet ugly
-             */
-            char *name = malloc(40);
-            bzero(name, 40);
-            fo = open(filename, O_RDONLY);
-            if (read(fo, name, 40) <0) {
-                perror("Error when reading file");
-            }
-            close(fo);
-            sendto(s, name, strlen(name) + 1 , MSG_NOSIGNAL,
-                   (struct sockaddr *)si_other, sizeof(*si_other));
-            logClientActivity(mac,
-                              LOG_DEBUG,
-                              PULSE_LOG_STATE_BACKUP,
-                              "'image UUID sent : %s'",
-                              name);
-            free(name);
-        } else {
-            sendto(s,
-                   ERRORSTR,
-                   strlen(ERRORSTR) + 1,
-                   MSG_NOSIGNAL,
-                   (struct sockaddr *)si_other,
-                   sizeof(*si_other));
-            logClientActivity(mac,
-                              LOG_WARNING,
-                              PULSE_LOG_STATE_BACKUP,
-                              "'failed to send an image UUID'");
-        }
-
-        unlink(filename);
-        return 0;
-    }
-
-    // after a save
-    if (buf[0] == 0xED) {
-        char uuid[37];
-        snprintf(uuid, sizeof(uuid), "%s", buf + 1);
-        logClientActivity(mac,
-                          LOG_DEBUG,
-                          PULSE_LOG_STATE_BACKUP,
-                          "'end-of-backup request : %s'",
-                          uuid);
-
-        if (mysystem(3, gPathEndImage, mac, uuid) == 0) {
-            sendto(s,
-                   ACKSTR,
-                   strlen(ACKSTR) + 1,
-                   MSG_NOSIGNAL,
-                   (struct sockaddr *)si_other,
-                   sizeof(*si_other));
-            logClientActivity(mac,
-                              LOG_DEBUG,
-                              PULSE_LOG_STATE_BACKUP,
-                              "'end-of-backup success : %s'",
-                              uuid);
-        } else {
-            sendto(s,
-                   ERRORSTR,
-                   strlen(ERRORSTR) + 1,
-                   MSG_NOSIGNAL,
-                   (struct sockaddr *)si_other,
-                   sizeof(*si_other));
-            logClientActivity(mac,
-                              LOG_WARNING,
-                              PULSE_LOG_STATE_BACKUP,
-                              "'end-of-backup failure : %s'",
-                              uuid);
-        }
-        return 0;
-    }
-
-    // Ask to change the default boot menu
-    if (buf[0] == 0xCD) {
-        char item[16];
-        snprintf(item, 16, "%d", buf[1]);
-
-        logClientActivity(mac,
-                          LOG_DEBUG,
-                          PULSE_LOG_STATE_MENU,
-                          "'preselected-menu-entry-change request : %s'",
-                          item);
-
-        if (mysystem(3, gPathChangeDefault, mac, item) == 0) {
-            logClientActivity(mac,
-                              LOG_DEBUG,
-                              PULSE_LOG_STATE_MENU,
-                              "'preselected-menu-entry-change success : %s'",
-                              item);
-            sendto(s,
-                   ACKSTR,
-                   strlen(ACKSTR) + 1,
-                   MSG_NOSIGNAL,
-                   (struct sockaddr *)si_other,
-                   sizeof(*si_other));
-        } else {
-            logClientActivity(mac,
-                              LOG_WARNING,
-                              PULSE_LOG_STATE_MENU,
-                              "'preselected-menu-entry-change failure' : %s",
-                              item);
-            sendto(s,
-                   ERRORSTR,
-                   strlen(ERRORSTR) + 1,
-                   MSG_NOSIGNAL,
-                   (struct sockaddr *)si_other,
-                   sizeof(*si_other));
-        }
-        return 0;
-    }
-
-    // log data
-    if (buf[0] == 0x4C) {       // 0x4C = 'L' as in *L*og
-        switch (buf[1]) {
-        case '0':
-            logClientActivity(mac,
-                              LOG_INFO,
-                              PULSE_LOG_STATE_BOOT,
-                              "'booted'");
-            return 0; // do not send ACK, it can conflict with the hostname request
-            break;
-        case '1':
-            logClientActivity(mac,
-                              LOG_INFO,
-                              PULSE_LOG_STATE_MENU,
-                              "'choosen menu entry : %d'",
-                              buf[2]);
-            break;
-        case '2':
-            if (buf[2] == '-') {
-                logClientActivity(mac,
-                                  LOG_INFO,
-                                  PULSE_LOG_STATE_RESTO,
-                                  "'restoration started : %s'",
-                                  &buf[3]);
-            } else {
-                logClientActivity(mac,
-                                  LOG_INFO,
-                                  PULSE_LOG_STATE_RESTO,
-                                  "'restoration started'");
-            }
-            break;
-        case '3':
-            if (buf[2] == '-') {
-                logClientActivity(mac,
-                                  LOG_INFO,
-                                  PULSE_LOG_STATE_RESTO,
-                                  "'restoration finished : %s'",
-                                  &buf[3]);
-            } else {
-                logClientActivity(mac,
-                                  LOG_INFO,
-                                  PULSE_LOG_STATE_RESTO,
-                                  "'restoration finished'");
-            }
-            lasttime = 0;       /* reset MTFTP time barriers */
-            lastfile = 0;
-            break;
-        case '4':
-            if (buf[2] == '-') {
-                logClientActivity(mac,
-                                  LOG_INFO,
-                                  PULSE_LOG_STATE_BACKUP,
-                                  "'backup started : %s'",
-                                  &buf[3]);
-            } else {
-                logClientActivity(mac,
-                                  LOG_INFO,
-                                  PULSE_LOG_STATE_BACKUP,
-                                  "'backup started'");
-            }
-            break;
-        case '5':
-            if (buf[2] == '-') {
-
-                logClientActivity(mac,
-                                  LOG_INFO,
-                                  PULSE_LOG_STATE_BACKUP,
-                                  "'backup finished : %s'",
-                                  &buf[3]);
-                // TODO : handle this pserver side
-                //MDV/NR if (sscanf((char*)&buf[3], "Local-%d", &bn) == 1) {
-                //MDV/NR // Local backup
-                //MDV/NR snprintf(command, 255, "chown -R 0:0 %s/images/%s/Local-%d", gBaseDir, smac, bn);
-                //MDV/NR system(command);
-                //MDV/NR } else if (sscanf((char*)&buf[3], "Base-%d", &bn) == 1) {
-                //MDV/NR // Shared backup
-                //MDV/NR snprintf(command, 255, "chown -R 0:0 %s/imgbase/Base-%d", gBaseDir, bn);
-                //MDV/NR system(command);
-                //MDV/NR }
-            } else {
-                logClientActivity(mac,
-                                  LOG_INFO,
-                                  PULSE_LOG_STATE_BACKUP,
-                                  "'backup finished'");
-            }
-            break;
-        case '6':
-            logClientActivity(mac,
-                              LOG_INFO,
-                              PULSE_LOG_STATE_POSTINST,
-                              "'postinstall started'");
-            break;
-        case '7':
-            logClientActivity(mac,
-                              LOG_INFO,
-                              PULSE_LOG_STATE_POSTINST,
-                              "'postinstall finished '");
-            break;
-        case '8':
-            logClientActivity(mac,
-                              LOG_ERR,
-                              PULSE_LOG_STATE_ERROR,
-                              "'critical error'");
-            break;
-
-        }
-        sendto(s, ACKSTR, strlen(ACKSTR) + 1, MSG_NOSIGNAL, (struct sockaddr *)si_other, sizeof(*si_other));
-        return 0;
-    }
-
-    // give me my Pulse 2 name
-    if (buf[0] == 0x1A) {
-        char filename[256];
-        // create a temporary file to get our hostname
-        snprintf(filename, 255, "/tmp/hostname.pulse2.%s.XXXXXX", smac);
-
-        logClientActivity(mac,
-                          LOG_DEBUG,
-                          PULSE_LOG_STATE_BOOT,
-                          "'hostname request'");
-
-        if (!(fo = mkstemp(filename))) {        // can't create .inf file
-            char *msg = malloc(256);
-            snprintf(msg, 256, "can't create %s", filename);
-            myLogger(msg);
-            free(msg);
-            logClientActivity(mac,
-                              LOG_ERR,
-                              PULSE_LOG_STATE_BOOT,
-                              "'failed to obtain a hostname'");
-            return 0;
-        }
-        close(fo);
-
-        if (mysystem(3, gPathGetHostName, mac, filename) == 0) {
-            /*
-             * thanks to system(), we do not have any chance to get our
-             * so we uses a temporary file to recover it.
-             * yes, that's quiet ugly
-             */
-            char *name = malloc(256);
-            bzero(name, 256);
-            fo = open(filename, O_RDONLY);
-            if (read(fo, name, 256) <0) {
-                perror("Error when reading file");
-            }
-            close(fo);
-            sendto(s, name, strlen(name) + 1 , MSG_NOSIGNAL,
-                   (struct sockaddr *)si_other, sizeof(*si_other));
-            logClientActivity(mac,
-                              LOG_DEBUG,
-                              PULSE_LOG_STATE_BOOT,
-                              "'hostname sent : %s'",
-                              name);
-            free(name);
-        } else {
-            sendto(s,
-                   ERRORSTR,
-                   strlen(ERRORSTR) + 1,
-                   MSG_NOSIGNAL,
-                   (struct sockaddr *)si_other,
-                   sizeof(*si_other));
-            logClientActivity(mac,
-                              LOG_WARNING,
-                              PULSE_LOG_STATE_BOOT,
-                              "'failed to send a hostname'");
-        }
-
-        unlink(filename);
-        return 0;
-    }
-
-    // give me my Pulse 2 UUID
-    if (buf[0] == 0x1B) {
-        char filename[256];
-        // create a temporary file to get our UUID
-        snprintf(filename, 255, "/tmp/uuid.pulse2.%s.XXXXXX", smac);
-
-        logClientActivity(mac,
-                          LOG_DEBUG,
-                          PULSE_LOG_STATE_BOOT,
-                          "'computer UUID request'");
-
-        if (!(fo = mkstemp(filename))) {        // can't create .inf file
-            char *msg = malloc(256);
-            snprintf(msg, 256, "can't create %s", filename);
-            myLogger(msg);
-            free(msg);
-            logClientActivity(mac,
-                              LOG_ERR,
-                              PULSE_LOG_STATE_BOOT,
-                              "'failed to recover a computer UUID'");
-            return 0;
-        }
-        close(fo);
-
-        if (mysystem(3, gPathGetUUID, mac, filename) == 0) {
-            /*
-             * thanks to system(), we do not have any chance to get our
-             * so we uses a temporary file to recover it.
-             * yes, that's quiet ugly
-             */
-            char *name = malloc(256);
-            bzero(name, 256);
-            fo = open(filename, O_RDONLY);
-            if (read(fo, name, 256) <0 ){
-                perror("Error when reading file");
-            }
-            close(fo);
-            sendto(s, name, strlen(name) + 1 , MSG_NOSIGNAL,
-                   (struct sockaddr *)si_other, sizeof(*si_other));
-            logClientActivity(mac,
-                              LOG_DEBUG,
-                              PULSE_LOG_STATE_BOOT,
-                              "'computer UUID sent : %s'",
-                              name);
-            free(name);
-        } else {
-            sendto(s,
-                   ERRORSTR,
-                   strlen(ERRORSTR) + 1,
-                   MSG_NOSIGNAL,
-                   (struct sockaddr *)si_other,
-                   sizeof(*si_other));
-            logClientActivity(mac,
-                              LOG_WARNING,
-                              PULSE_LOG_STATE_BOOT,
-                              "'failed to send a computer UUID");
-        }
-
-        unlink(filename);
-        return 0;
-    }
-
-    /* mtftp synchro */
-    if (buf[0] == 'T') {
-        char pnum;
-        int bnum, to;
-
-        if (sscanf((char *)buf, "T;%c%d;%d", &pnum, &bnum, &to) == 3) {
-            unsigned int file = (pnum << 16) + bnum;
-            int wait = 0;
-
-            if (time(NULL) - lasttime > 3600) {
-                lasttime = 0;   /* reset MTFTP time barriers */
-                lastfile = 0;
-            }
-
-            if (file == lastfile) {
-                /* wait barrier */
-                wait = to + (lasttime - time(NULL));
-                if (wait < 0)
-                    wait = 0;
-            } else if (file < lastfile) {
-                wait = 0;
-            } else if (file > lastfile) {
-                /* reinit barrier */
-                wait = to;
-                if (lasttime == 0)
-                    wait = wait + 10;   /* 1st wait after a boot */
-                lastfile = file;
-                lasttime = time(NULL);
-            }
-            //printf("%c %d %d %d\n", pnum, bnum, to, wait);
-
-            sprintf((char *)buf, "%d", wait);
-            sendto(s, buf, strlen((char *)buf), MSG_NOSIGNAL,
-                   (struct sockaddr *)si_other, sizeof(*si_other));
-
-            return 0;
-        }
-    }
-
-    return 1;
-}
-
-void readConfig(char *config_file_path) {
-    char *tmp;
-
-    ini = iniparser_load(config_file_path);
-
-    if (ini == NULL) {
-        char msg[PATH_MAX];
-        snprintf(msg, sizeof(msg), "cannot parse file %.900s", config_file_path);
-        syslog(LOG_ERR, "%s", msg);
-        diep(msg);
-    }
-    // Parse MAIN section //
-
-    tmp = iniparser_getstring(ini, "main:host", "0.0.0.0");
-    snprintf(gHost, 256, "%s", tmp);
-    syslog(LOG_DEBUG, "[main] host = %s", gHost);
-
-    gPort = iniparser_getint(ini, "main:port", 1001);
-    syslog(LOG_DEBUG, "[main] port = %d", gPort);
-
-    tmp = iniparser_getstring(ini, "main:adminpass", "");
-    snprintf(gAdminPass, 256, "%s", tmp);
-    syslog(LOG_DEBUG, "[main] adminpass = ****");
-
-    // Parse DAEMON section //
-    gUser = iniparser_getstring(ini, "daemon:user", "root");
-    syslog(LOG_DEBUG, "[daemon] user = %s", gUser);
-    gGroup = iniparser_getstring(ini, "daemon:group", "root");
-    syslog(LOG_DEBUG, "[daemon] group = %s", gGroup);
-    gUMask = iniparser_getint(ini, "daemon:umask", 0077);
-    syslog(LOG_DEBUG, "[daemon] umask = %d", gUMask);
-    gPIDFile =
-        iniparser_getstring(ini, "daemon:pidfile",
-                            "/var/run/pulse2-imaging-server.pid");
-    syslog(LOG_DEBUG, "[daemon] pidfile = %s", gPIDFile);
-
-    // Parse HOOKS section //
-    tmp = iniparser_getstring(ini, "hooks:hooks_dir",
-                              "/usr/lib/pulse2/imaging-server/hooks");
-    snprintf(gDirHooks, 256, "%s", tmp);
-    syslog(LOG_DEBUG, "[hooks] hooks_dir = %s", gDirHooks);
-
-    tmp = iniparser_getstring(ini, "hooks:create_client_path", "create_client");
-    snprintf(gPathCreateClient, 256, "%s/%s", gDirHooks, tmp);
-    syslog(LOG_DEBUG, "[hooks] create_client_path = %s", gPathCreateClient);
-
-    tmp = iniparser_getstring(ini, "hooks:boot_client_path", "boot_client");
-    snprintf(gPathBootClient, 256, "%s/%s", gDirHooks, tmp);
-    syslog(LOG_DEBUG, "[hooks] boot_client_path = %s", gPathBootClient);
-
-    char tmp1[]="client_auth";
-    //snprintf(gClient_auth, 256, "%s/%s", gDirHooks, tmp);
-    snprintf(gClient_auth, 256, "%s/%s", gDirHooks, tmp1);
-    syslog(LOG_DEBUG, "[hooks] process_client_auth = %s",
-           gClient_auth);
-    
-    tmp =
-        iniparser_getstring(ini, "hooks:process_inventory_path",
-                            "process_inventory");
-    snprintf(gPathProcessInventory, 256, "%s/%s", gDirHooks, tmp);
-    syslog(LOG_DEBUG, "[hooks] process_inventory_path = %s",
-           gPathProcessInventory);
-
-    tmp = iniparser_getstring(ini, "hooks:start_image_path", "start_image");
-    snprintf(gPathStartImage, 256, "%s/%s", gDirHooks, tmp);
-    syslog(LOG_DEBUG, "[hooks] start_image_path = %s", gPathStartImage);
-
-    tmp = iniparser_getstring(ini, "hooks:end_image_path", "end_image");
-    snprintf(gPathEndImage, 256, "%s/%s", gDirHooks, tmp);
-    syslog(LOG_DEBUG, "[hooks] end_image_path = %s", gPathEndImage);
-
-    tmp = iniparser_getstring(ini, "hooks:log_action_path", "log_action");
-    snprintf(gPathLogAction, 256, "%s/%s", gDirHooks, tmp);
-    syslog(LOG_DEBUG, "[hooks] log_action_path = %s", gPathLogAction);
-
-    tmp = iniparser_getstring(ini, "hooks:get_uuid_path", "get_uuid");
-    snprintf(gPathGetUUID, 256, "%s/%s", gDirHooks, tmp);
-    syslog(LOG_DEBUG, "[hooks] get_uuid_path = %s", gPathGetUUID);
-
-    tmp = iniparser_getstring(ini, "hooks:get_hostname_path", "get_hostname");
-    snprintf(gPathGetHostName, 256, "%s/%s", gDirHooks, tmp);
-    syslog(LOG_DEBUG, "[hooks] get_hostname_path = %s", gPathGetHostName);
-
-    tmp = iniparser_getstring(ini, "hooks:mtftp_sync_path", "mtftp_sync");
-    snprintf(gPathMTFTPSync, 256, "%s/%s", gDirHooks, tmp);
-    syslog(LOG_DEBUG, "[hooks] mtftp_sync_path = %s", gPathMTFTPSync);
-
-    tmp = iniparser_getstring(ini, "hooks:change_default_path", "change_default");
-    snprintf(gPathChangeDefault, 256, "%s/%s", gDirHooks, tmp);
-    syslog(LOG_DEBUG, "[hooks] change_default_path = %s", gPathChangeDefault);
-
-    // Parse LOGGER section : get args keyword from handler_hand01 section//
-    gLogFile =
-        iniparser_getstring(ini, "handler_hand01:args",
-                            "(/var/log/mmc/pulse2-imaging-server.log,)");
-    gLogFile += 2;
-    *(gLogFile + strlen(gLogFile) - 3) = 0;
-    syslog(LOG_INFO, "[handler_hand01] args = %s", gLogFile);
-
-    myLogger("Configuration parsed");
-}
-
-/* MAIN */
-int main(void) {
-    struct sockaddr_in si_me, si_other, si_tcp;
-    int s, slen = sizeof(si_other), plen, stcp;
-    unsigned char buf[BUFLEN];
-    char smac[20];
-    char *mac;
-    fd_set fds;
-    int on = 1;
-    int pidFileFD;
-    int pid = 0;
-    char pidBuff[6];
-    bzero(pidBuff, 6);
-
-    syslog(LOG_INFO, "pulse2-imaging-server r.$Revision$");
-
-    initlog();
-    readConfig(gConfigurationFile);
-
-    /* Daemonize here */
-    if ((daemon(0, 0) != 0)) {
-        diep("daemon");
-    }
-
-    pid = getpid();
-    if (pid) {
-        char *msg = malloc(256);
-        bzero(msg, 256);
-        snprintf(msg, sizeof(msg), "daemonization succedeed, PID is %d", pid);
-        syslog(LOG_INFO, "%s", msg);
-    } else {
-        diep("daemon");
-    }
-
-    if ((s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1)
-        diep("udp socket");
-    if ((stcp = socket(AF_INET, SOCK_STREAM, 0)) == -1)
-        diep("tcp socket");
-
-    /* UDP sock */
-    memset((char *)&si_me, 0, sizeof(si_me));
-    si_me.sin_family = AF_INET;
-    si_me.sin_port = htons(gPort);
-    si_me.sin_addr.s_addr = htonl(INADDR_ANY);
-    if (bind(s, (struct sockaddr *)&si_me, sizeof(si_me)) == -1)
-        diep("bind UDP");
-
-    /* TCP sock */
-    if (setsockopt(stcp, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) != 0)
-        syslog(LOG_DEBUG, "SO_REUSEADDR failed");
-
-    memset((char *)&si_tcp, 0, sizeof(si_tcp));
-    si_tcp.sin_family = AF_INET;
-    si_tcp.sin_port = htons(gPort);
-    si_tcp.sin_addr.s_addr = htonl(INADDR_ANY);
-    if (bind(stcp, (struct sockaddr *)&si_tcp, sizeof(si_tcp)) == -1)
-        diep("bind TCP");
-    listen(stcp, 1000);
-
-    pidFileFD = open((char *)gPIDFile, O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU);
-    if (pidFileFD == -1)
-        diep("Can't open PID file");
-    snprintf(pidBuff, sizeof(pidBuff), "%d", pid);
-    if (write(pidFileFD, pidBuff, strlen(pidBuff)) < 0 ) {
-        perror("Error when writing file");
-    }
-    close(pidFileFD);
-
-    while (1) {
-        int so;                 /* tcp/udp stream FD */
-        /* select */
-        FD_ZERO(&fds);
-        FD_SET(s, &fds);
-        FD_SET(stcp, &fds);
-
-        select(stcp + 1, &fds, NULL, NULL, NULL);
-        if (FD_ISSET(stcp, &fds)) {
-            so = accept(stcp, (struct sockaddr *)&si_other,
-                        (unsigned int *)&slen);
-            if (so == -1)
-                continue;
-            if ((plen =
-                 recvfrom(so, buf, BUFLEN, 0,
-                          (struct sockaddr *)NULL, NULL)) == -1)
-                diep("recvfrom()");
-        } else if (FD_ISSET(s, &fds)) {
-            so = s;
-            if ((plen =
-                 recvfrom(so, buf, BUFLEN, 0,
-                          (struct sockaddr *)&si_other,
-                          (unsigned int *)&slen)) == -1)
-                diep("recvfrom()");
-
-        } else {
-            continue;
-        }
-
-        /* UDP only */
-        if ((mac = (char *)getmacfrompkt((char *)buf, plen))) {
-            // got it from the request ! good !
-        } else {
-            // Pas beau...(utilise le cache ARP) (for backward compatibility)
-            mac = (char *)getmac(si_other.sin_addr);
-        }
-        if (!mac) {
-            strcpy((char *)gBuff, "?");
-            mac = (char *)gBuff;
-        }
-
-        /* client port must be 1001 ! */
-        if (ntohs(si_other.sin_port) != 1001) {
-            if (so != s)
-                close(so);
-            continue;
-        }
-
-        /* short mac */
-        sprintf(smac, "%c%c%c%c%c%c%c%c%c%c%c%c", mac[0], mac[1], mac[3],
-                mac[4], mac[6], mac[7], mac[9], mac[10], mac[12], mac[13],
-                mac[15], mac[16]);
-
-        /* process */
-        process_packet(buf, mac, smac, &si_other, so);
-
-        /* eventually close the tcp stream */
-        if (so != s)
-            close(so);
-
-        //MDV/NR nb = getentries((unsigned char*)etherpath);
-    }
-
-    close(s);
-    return 0;
-}
diff --git a/pulse2/services/src/pulse2-imaging-server.h b/pulse2/services/src/pulse2-imaging-server.h
deleted file mode 100644
index a1aa0eb..0000000
--- a/pulse2/services/src/pulse2-imaging-server.h
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * (c) 2009-2010 Mandriva, http://www.mandriva.com
- *
- * $Id$
- *
- * This file is part of Pulse 2, http://pulse2.mandriva.org
- *
- * Pulse 2 is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Pulse 2 is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with Pulse 2; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA 02110-1301, USA.
- */
-
-#ifndef PULSE_IMAGING_SERVER_H
-#define PULSE_IMAGING_SERVER_H
-
-#include <stdio.h>
-#include <stdarg.h>
-#include <sys/types.h>
-#include <fcntl.h>
-#include <sys/socket.h>
-#include <unistd.h>
-#include <math.h>
-#include <errno.h>
-#include <ctype.h>
-#include <syslog.h>
-#include <time.h>
-#include <dirent.h>
-#include <sys/wait.h> // for WEXITSTATUS and friends
-#include <sys/stat.h>
-
-#ifdef S_SPLINT_S
-# include "/usr/local/splint/include/arpa/inet.h"
-#else
-# include <arpa/inet.h>
-#endif
-#include <netinet/in.h>
-
-#include "iniparser.h"
-#include "site.h"
-
-#define BUFLEN 1532
-#define ERRORSTR "ERROR"
-#define ACKSTR "ACK"
-#define CONFIGURATION_FILE EXPAND_CONF("/mmc/pulse2/imaging-server/imaging-server.ini")
-
-unsigned char gBuff[80];
-
-char *gConfigurationFile = CONFIGURATION_FILE;
-
-// global config options, main section
-char gHost[256];
-int gPort = 0;
-char gAdminPass[256];
-// global config options, helpers section
-char gDirHooks[256];
-char gPathProcessInventory[256];
-char gPathCreateClient[256];
-char gPathStartImage[256];
-char gPathBootClient[256];
-char gPathChangeDefault[256];
-char gPathEndImage[256];
-char gPathLogAction[256];
-char gPathGetUUID[256];
-char gPathGetHostName[256];
-char gPathMTFTPSync[256];
-char gClient_auth[256];
-// global config options, daemon section
-char *gUser;
-char *gGroup;
-int gUMask;
-char *gPIDFile;
-// global config options, logs section
-char *gLogFile;
-dictionary *ini;
-
-#define PULSE_LOG_STATE_BOOT "boot"
-#define PULSE_LOG_STATE_MENU "menu"
-#define PULSE_LOG_STATE_RESTO "restoration"
-#define PULSE_LOG_STATE_BACKUP "backup"
-#define PULSE_LOG_STATE_POSTINST "postinst"
-#define PULSE_LOG_STATE_ERROR "error"
-#define PULSE_LOG_STATE_DELETE "delete"
-#define PULSE_LOG_STATE_INVENTORY "inventory"
-#define PULSE_LOG_STATE_INDENTITY "identity"
-
-#endif                          //PULSE_IMAGING_SERVER_H
diff --git a/pulse2/services/src/site.h b/pulse2/services/src/site.h
deleted file mode 100644
index 1ac66dc..0000000
--- a/pulse2/services/src/site.h
+++ /dev/null
@@ -1 +0,0 @@
-#define EXPAND_CONF(path) SYSCONFDIR path
diff --git a/pulse2/services/src/strlib.c b/pulse2/services/src/strlib.c
deleted file mode 100644
index 627a173..0000000
--- a/pulse2/services/src/strlib.c
+++ /dev/null
@@ -1,211 +0,0 @@
-
-/*-------------------------------------------------------------------------*/
-/**
-  @file		strlib.c
-  @author	N. Devillard
-  @date		Jan 2001
-  @version	$Revision$
-  @brief	Various string handling routines to complement the C lib.
-
-  This modules adds a few complementary string routines usually missing
-  in the standard C library.
-*/
-/*--------------------------------------------------------------------------*/
-
-/*
-	$Id$
-	$Author$
-	$Date$
-	$Revision$
-*/
-
-/*---------------------------------------------------------------------------
-   								Includes
- ---------------------------------------------------------------------------*/
-
-#include <string.h>
-#include <ctype.h>
-
-#include "strlib.h"
-
-/*---------------------------------------------------------------------------
-   							    Defines	
- ---------------------------------------------------------------------------*/
-#define ASCIILINESZ	1024
-
-/*---------------------------------------------------------------------------
-  							Function codes
- ---------------------------------------------------------------------------*/
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief	Convert a string to lowercase.
-  @param	s	String to convert.
-  @return	ptr to statically allocated string.
-
-  This function returns a pointer to a statically allocated string
-  containing a lowercased version of the input string. Do not free
-  or modify the returned string! Since the returned string is statically
-  allocated, it will be modified at each function call (not re-entrant).
- */
-/*--------------------------------------------------------------------------*/
-
-char * strlwc(char * s)
-{
-    static char l[ASCIILINESZ+1];
-    int i ;
-
-    if (s==NULL) return NULL ;
-    memset(l, 0, ASCIILINESZ+1);
-    i=0 ;
-    while (s[i] && i<ASCIILINESZ) {
-        l[i] = (char)tolower((int)s[i]);
-        i++ ;
-    }
-    l[ASCIILINESZ]=(char)0;
-    return l ;
-}
-
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief	Convert a string to uppercase.
-  @param	s	String to convert.
-  @return	ptr to statically allocated string.
-
-  This function returns a pointer to a statically allocated string
-  containing an uppercased version of the input string. Do not free
-  or modify the returned string! Since the returned string is statically
-  allocated, it will be modified at each function call (not re-entrant).
- */
-/*--------------------------------------------------------------------------*/
-
-char * strupc(char * s)
-{
-    static char l[ASCIILINESZ+1];
-    int i ;
-
-    if (s==NULL) return NULL ;
-    memset(l, 0, ASCIILINESZ+1);
-    i=0 ;
-    while (s[i] && i<ASCIILINESZ) {
-        l[i] = (char)toupper((int)s[i]);
-        i++ ;
-    }
-    l[ASCIILINESZ]=(char)0;
-    return l ;
-}
-
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief	Skip blanks until the first non-blank character.
-  @param	s	String to parse.
-  @return	Pointer to char inside given string.
-
-  This function returns a pointer to the first non-blank character in the
-  given string.
- */
-/*--------------------------------------------------------------------------*/
-
-char * strskp(char * s)
-{
-    char * skip = s;
-	if (s==NULL) return NULL ;
-    while (isspace((int)*skip) && *skip) skip++;
-    return skip ;
-} 
-
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief	Remove blanks at the end of a string.
-  @param	s	String to parse.
-  @return	ptr to statically allocated string.
-
-  This function returns a pointer to a statically allocated string,
-  which is identical to the input string, except that all blank
-  characters at the end of the string have been removed.
-  Do not free or modify the returned string! Since the returned string
-  is statically allocated, it will be modified at each function call
-  (not re-entrant).
- */
-/*--------------------------------------------------------------------------*/
-
-char * strcrop(char * s)
-{
-    static char l[ASCIILINESZ+1];
-	char * last ;
-
-    if (s==NULL) return NULL ;
-    memset(l, 0, ASCIILINESZ+1);
-	strcpy(l, s);
-	last = l + strlen(l);
-	while (last > l) {
-		if (!isspace((int)*(last-1)))
-			break ;
-		last -- ;
-	}
-	*last = (char)0;
-    return l ;
-}
-
-
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief	Remove blanks at the beginning and the end of a string.
-  @param	s	String to parse.
-  @return	ptr to statically allocated string.
-
-  This function returns a pointer to a statically allocated string,
-  which is identical to the input string, except that all blank
-  characters at the end and the beg. of the string have been removed.
-  Do not free or modify the returned string! Since the returned string
-  is statically allocated, it will be modified at each function call
-  (not re-entrant).
- */
-/*--------------------------------------------------------------------------*/
-char * strstrip(char * s)
-{
-    static char l[ASCIILINESZ+1];
-	char * last ;
-	
-    if (s==NULL) return NULL ;
-    
-	while (isspace((int)*s) && *s) s++;
-	
-	memset(l, 0, ASCIILINESZ+1);
-	strcpy(l, s);
-	last = l + strlen(l);
-	while (last > l) {
-		if (!isspace((int)*(last-1)))
-			break ;
-		last -- ;
-	}
-	*last = (char)0;
-
-	return (char*)l ;
-}
-
-/* Test code */
-#ifdef TEST
-int main(int argc, char * argv[])
-{
-	char * str ;
-
-	str = "\t\tI'm a lumberkack and I'm OK      " ;
-	printf("lowercase: [%s]\n", strlwc(str));
-	printf("uppercase: [%s]\n", strupc(str));
-	printf("skipped  : [%s]\n", strskp(str));
-	printf("cropped  : [%s]\n", strcrop(str));
-	printf("stripped : [%s]\n", strstrip(str));
-
-	return 0 ;
-}
-#endif
-/* vim: set ts=4 et sw=4 tw=75 */
diff --git a/pulse2/services/src/strlib.h b/pulse2/services/src/strlib.h
deleted file mode 100644
index 75e14c5..0000000
--- a/pulse2/services/src/strlib.h
+++ /dev/null
@@ -1,108 +0,0 @@
-
-/*-------------------------------------------------------------------------*/
-/**
-  @file     strlib.h
-  @author   N. Devillard
-  @date     Jan 2001
-  @version  $Revision$
-  @brief    Various string handling routines to complement the C lib.
-
-  This modules adds a few complementary string routines usually missing
-  in the standard C library.
-*/
-/*--------------------------------------------------------------------------*/
-
-/*
-	$Id$
-	$Author$
-	$Date$
-	$Revision$
-*/
-
-#ifndef _STRLIB_H_
-#define _STRLIB_H_
-
-/*---------------------------------------------------------------------------
-   								Includes
- ---------------------------------------------------------------------------*/
-
-#include <stdio.h>
-#include <stdlib.h>
-
-/*---------------------------------------------------------------------------
-  							Function codes
- ---------------------------------------------------------------------------*/
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Convert a string to lowercase.
-  @param    s   String to convert.
-  @return   ptr to statically allocated string.
-
-  This function returns a pointer to a statically allocated string
-  containing a lowercased version of the input string. Do not free
-  or modify the returned string! Since the returned string is statically
-  allocated, it will be modified at each function call (not re-entrant).
- */
-/*--------------------------------------------------------------------------*/
-char * strlwc(char * s);
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Convert a string to uppercase.
-  @param    s   String to convert.
-  @return   ptr to statically allocated string.
-
-  This function returns a pointer to a statically allocated string
-  containing an uppercased version of the input string. Do not free
-  or modify the returned string! Since the returned string is statically
-  allocated, it will be modified at each function call (not re-entrant).
- */
-/*--------------------------------------------------------------------------*/
-char * strupc(char * s);
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Skip blanks until the first non-blank character.
-  @param    s   String to parse.
-  @return   Pointer to char inside given string.
-
-  This function returns a pointer to the first non-blank character in the
-  given string.
- */
-/*--------------------------------------------------------------------------*/
-char * strskp(char * s);
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Remove blanks at the end of a string.
-  @param    s   String to parse.
-  @return   ptr to statically allocated string.
-
-  This function returns a pointer to a statically allocated string,
-  which is identical to the input string, except that all blank
-  characters at the end of the string have been removed.
-  Do not free or modify the returned string! Since the returned string
-  is statically allocated, it will be modified at each function call
-  (not re-entrant).
- */
-/*--------------------------------------------------------------------------*/
-char * strcrop(char * s);
-
-/*-------------------------------------------------------------------------*/
-/**
-  @brief    Remove blanks at the beginning and the end of a string.
-  @param    s   String to parse.
-  @return   ptr to statically allocated string.
-
-  This function returns a pointer to a statically allocated string,
-  which is identical to the input string, except that all blank
-  characters at the end and the beg. of the string have been removed.
-  Do not free or modify the returned string! Since the returned string
-  is statically allocated, it will be modified at each function call
-  (not re-entrant).
- */
-/*--------------------------------------------------------------------------*/
-char * strstrip(char * s) ;
-
-#endif
